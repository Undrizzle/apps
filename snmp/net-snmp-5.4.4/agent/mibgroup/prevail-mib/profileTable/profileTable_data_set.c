/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "profileTable.h"
#include <snmp2cmm.h>
#include <dbsapi.h>


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table profileTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * prevail-mib::profileTable is subid 8 of modEoCMib.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.36186.8.8, length: 9
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * profileTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * profileTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
profileTable_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:profileTable:profileTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup profileTable undo.
     * set up profileTable undo information, in preparation for a set.
     * Undo storage is in (* proRowStatus_val_ptr )*
     */

    return rc;
} /* profileTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
profileTable_undo( profileTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:profileTable:profileTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> profileTable undo.
     * profileTable undo information, in response to a failed set.
     * Undo storage is in (* proRowStatus_val_ptr )*
     */

    return rc;
} /* profileTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
profileTable_undo_cleanup( profileTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:profileTable:profileTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup profileTable undo.
     * Undo storage is in (* proRowStatus_val_ptr )*
     */

    return rc;
} /* profileTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * profileTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param profileTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int profileTable_commit( profileTable_rowreq_ctx *rowreq_ctx)
{
	int rc = MFD_SUCCESS;    
	/* Modified by frank */
	//int             save_flags;
	uint64_t             save_flags;
	DB_INTEGER_V iValue;

	DEBUGMSGTL(("verbose:profileTable:profileTable_commit","called\n"));

	/** we should have a non-NULL pointer */
	netsnmp_assert( NULL != rowreq_ctx );

	/*
	* save flags, then clear until we actually do something
	*/
	save_flags = rowreq_ctx->column_set_flags;
	rowreq_ctx->column_set_flags = 0;

	iValue.ci.tbl = DBS_SYS_TBL_ID_CNUPRO;
	iValue.ci.row = rowreq_ctx->data.proIndex;
	iValue.ci.colType = DBS_INTEGER;
	iValue.len = sizeof(uint32_t);
	/*
	* commit profileTable data
	* 1) check the column's flag in save_flags to see if it was set.
	* 2) clear the flag when you handle that column
	* 3) set the column's flag in column_set_flags if it needs undo
	*    processing in case of a failure.
	*/
	if( 0 == rowreq_ctx->data.proRowStatus )
	{
		dbs_sys_log(dbsdev, DBS_LOG_WARNING, "module snmp profileTable_commit in bad proRowStatus");
	}
	
	if (save_flags & COLUMN_PROBASE_FLAG)
	{
       	save_flags &= ~COLUMN_PROBASE_FLAG; /* clear proBase */
		/*
		* TODO:482:o: |-> commit column proBase.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_BASE;
		iValue.integer = rowreq_ctx->data.proBase;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proBase commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proBase
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROBASE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROMACLIMIT_FLAG)
	{
		save_flags &= ~COLUMN_PROMACLIMIT_FLAG; /* clear proMacLimit */
		/*
		* TODO:482:o: |-> commit column proMacLimit.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_MACLIMIT;
		iValue.integer = rowreq_ctx->data.proMacLimit;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proMacLimit commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proMacLimit
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROMACLIMIT_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCABLEUPLINKRATE_FLAG)
	{
		save_flags &= ~COLUMN_PROCABLEUPLINKRATE_FLAG; /* clear proCableUplinkRate */
		/*
		* TODO:482:o: |-> commit column proCableUplinkRate.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_CURATE;
		iValue.integer = rowreq_ctx->data.proCableUplinkRate;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCableUplinkRate commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCableUplinkRate
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCABLEUPLINKRATE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCABLEDOWNLINKRATE_FLAG)
	{
		save_flags &= ~COLUMN_PROCABLEDOWNLINKRATE_FLAG; /* clear proCableDownlinkRate */
		/*
		* TODO:482:o: |-> commit column proCableDownlinkRate.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_CDRATE;
		iValue.integer = rowreq_ctx->data.proCableDownlinkRate;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCableDownlinkRate commit failed\n");
		}
		else
		{
			/*
             * set flag, in case we need to undo proCableDownlinkRate
             */
			rc = 0;
			 rowreq_ctx->column_set_flags |= COLUMN_PROCABLEDOWNLINKRATE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROLOCALAGINGTIME_FLAG)
	{
       	save_flags &= ~COLUMN_PROLOCALAGINGTIME_FLAG; /* clear proLocalAgingTime */
		/*
		* TODO:482:o: |-> commit column proLocalAgingTime.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_LOAGE;
		iValue.integer = rowreq_ctx->data.proLocalAgingTime;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proLocalAgingTime commit failed\n");
		}
		else
		{
			/*
             * set flag, in case we need to undo proLocalAgingTime
             */
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROLOCALAGINGTIME_FLAG;
		}
	}

	if (save_flags & COLUMN_PROREMOTEAGINGTIME_FLAG)
	{
		save_flags &= ~COLUMN_PROREMOTEAGINGTIME_FLAG; /* clear proRemoteAgingTime */
		/*
		* TODO:482:o: |-> commit column proRemoteAgingTime.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_REAGE;
		iValue.integer = rowreq_ctx->data.proRemoteAgingTime;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proRemoteAgingTime commit failed\n");
		}
		else
		{
			/*
             * set flag, in case we need to undo proRemoteAgingTime
             */
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROREMOTEAGINGTIME_FLAG;
		}
	}

	if (save_flags & COLUMN_PROIGMPPRI_FLAG)
	{
		save_flags &= ~COLUMN_PROIGMPPRI_FLAG; /* clear proIgmpPri */
		/*
		* TODO:482:o: |-> commit column proIgmpPri.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_IGMPPRI;
		iValue.integer = rowreq_ctx->data.proIgmpPri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proIgmpPri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proIgmpPri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROIGMPPRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROUNICASTPRI_FLAG)
	{
		save_flags &= ~COLUMN_PROUNICASTPRI_FLAG; /* clear proUnicastPri */
		/*
		* TODO:482:o: |-> commit column proUnicastPri.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_UNIPRI;
		iValue.integer = rowreq_ctx->data.proUnicastPri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proUnicastPri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proUnicastPri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROUNICASTPRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROAVSPRI_FLAG)
	{
		save_flags &= ~COLUMN_PROAVSPRI_FLAG; /* clear proAvsPri */
		/*
		* TODO:482:o: |-> commit column proAvsPri.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_AVSPRI;
		iValue.integer = rowreq_ctx->data.proAvsPri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proAvsPri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proAvsPri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROAVSPRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROMCASTPRI_FLAG)
	{
		save_flags &= ~COLUMN_PROMCASTPRI_FLAG; /* clear proMcastPri */
		/*
		* TODO:482:o: |-> commit column proMcastPri.
		*/
		/* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_MCPRI;
		iValue.integer = rowreq_ctx->data.proMcastPri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proMcastPri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proMcastPri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROMCASTPRI_FLAG;
		}
    }

	if (save_flags & COLUMN_PROTBAPRISTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROTBAPRISTS_FLAG; /* clear proTbaPriSts */
	       /*
	        * TODO:482:o: |-> commit column proTbaPriSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TBAPRISTS;
		//iValue.integer = rowreq_ctx->data.proTbaPriSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proTbaPriSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTbaPriSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTbaPriSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTBAPRISTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOSPRISTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOSPRISTS_FLAG; /* clear proCosPriSts */
	       /*
	        * TODO:482:o: |-> commit column proCosPriSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COSPRISTS;
		//iValue.integer = rowreq_ctx->data.proCosPriSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proCosPriSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCosPriSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCosPriSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOSPRISTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS0PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS0PRI_FLAG; /* clear proCos0pri */
	       /*
	        * TODO:482:o: |-> commit column proCos0pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS0PRI;
		iValue.integer = rowreq_ctx->data.proCos0pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos0pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos0pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS0PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS1PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS1PRI_FLAG; /* clear proCos1pri */
	       /*
	        * TODO:482:o: |-> commit column proCos1pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS1PRI;
		iValue.integer = rowreq_ctx->data.proCos1pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos1pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos1pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS1PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS2PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS2PRI_FLAG; /* clear proCos2pri */
	       /*
	        * TODO:482:o: |-> commit column proCos2pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS2PRI;
		iValue.integer = rowreq_ctx->data.proCos2pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos2pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos2pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS2PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS3PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS3PRI_FLAG; /* clear proCos3pri */
	       /*
	        * TODO:482:o: |-> commit column proCos3pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS3PRI;
		iValue.integer = rowreq_ctx->data.proCos3pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos3pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos3pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS3PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS4PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS4PRI_FLAG; /* clear proCos4pri */
	       /*
	        * TODO:482:o: |-> commit column proCos4pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS4PRI;
		iValue.integer = rowreq_ctx->data.proCos4pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos4pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos4pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS4PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS5PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS5PRI_FLAG; /* clear proCos5pri */
	       /*
	        * TODO:482:o: |-> commit column proCos5pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS5PRI;
		iValue.integer = rowreq_ctx->data.proCos5pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos5pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos5pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS5PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS6PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS6PRI_FLAG; /* clear proCos6pri */
	       /*
	        * TODO:482:o: |-> commit column proCos6pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS6PRI;
		iValue.integer = rowreq_ctx->data.proCos6pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos6pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos6pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS6PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOS7PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOS7PRI_FLAG; /* clear proCos7pri */
	       /*
	        * TODO:482:o: |-> commit column proCos7pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_COS7PRI;
		iValue.integer = rowreq_ctx->data.proCos7pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCos7pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCos7pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCOS7PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOSPRISTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOSPRISTS_FLAG; /* clear proTosPriSts */
	       /*
	        * TODO:482:o: |-> commit column proTosPriSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOSPRISTS;
		//iValue.integer = rowreq_ctx->data.proTosPriSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proTosPriSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTosPriSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTosPriSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOSPRISTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS0PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS0PRI_FLAG; /* clear proTos0pri */
	       /*
	        * TODO:482:o: |-> commit column proTos0pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS0PRI;
		iValue.integer = rowreq_ctx->data.proTos0pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos0pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos0pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS0PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS1PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS1PRI_FLAG; /* clear proTos1pri */
	       /*
	        * TODO:482:o: |-> commit column proTos1pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS1PRI;
		iValue.integer = rowreq_ctx->data.proTos1pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos1pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos1pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS1PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS2PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS2PRI_FLAG; /* clear proTos2pri */
	       /*
	        * TODO:482:o: |-> commit column proTos2pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS2PRI;
		iValue.integer = rowreq_ctx->data.proTos2pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos2pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos2pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS2PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS3PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS3PRI_FLAG; /* clear proTos3pri */
	       /*
	        * TODO:482:o: |-> commit column proTos3pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS3PRI;
		iValue.integer = rowreq_ctx->data.proTos3pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos3pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos3pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS3PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS4PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS4PRI_FLAG; /* clear proTos4pri */
	       /*
	        * TODO:482:o: |-> commit column proTos4pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS4PRI;
		iValue.integer = rowreq_ctx->data.proTos4pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos4pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos4pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS4PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS5PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS5PRI_FLAG; /* clear proTos5pri */
	       /*
	        * TODO:482:o: |-> commit column proTos5pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS5PRI;
		iValue.integer = rowreq_ctx->data.proTos5pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos5pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos5pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS5PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS6PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS6PRI_FLAG; /* clear proTos6pri */
	       /*
	        * TODO:482:o: |-> commit column proTos6pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS6PRI;
		iValue.integer = rowreq_ctx->data.proTos6pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos6pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos6pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS6PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTOS7PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROTOS7PRI_FLAG; /* clear proTos7pri */
	       /*
	        * TODO:482:o: |-> commit column proTos7pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TOS7PRI;
		iValue.integer = rowreq_ctx->data.proTos7pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTos7pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTos7pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTOS7PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROSFBSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROSFBSTS_FLAG; /* clear proSfbSts */
	       /*
	        * TODO:482:o: |-> commit column proSfbSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_SFBSTS;
		//iValue.integer = rowreq_ctx->data.proSfbSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proSfbSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proSfbSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proSfbSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROSFBSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROSFUSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROSFUSTS_FLAG; /* clear proSfuSts */
	       /*
	        * TODO:482:o: |-> commit column proSfuSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_SFUSTS;
		//iValue.integer = rowreq_ctx->data.proSfuSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proSfuSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proSfuSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proSfuSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROSFUSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROSFMSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROSFMSTS_FLAG; /* clear proSfmSts */
	       /*
	        * TODO:482:o: |-> commit column proSfmSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_SFMSTS;
		//iValue.integer = rowreq_ctx->data.proSfmSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proSfmSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proSfmSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proSfmSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROSFMSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROSFRATE_FLAG) 
	{
	       save_flags &= ~COLUMN_PROSFRATE_FLAG; /* clear proSfRate */
	       /*
	        * TODO:482:o: |-> commit column proSfRate.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_SFRATE;
		iValue.integer = rowreq_ctx->data.proSfRate;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proSfRate commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proSfRate
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROSFRATE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROVLANSTATUS_FLAG)
	{
	       save_flags &= ~COLUMN_PROVLANSTATUS_FLAG; /* clear proVlanStatus */
	       /*
	        * TODO:482:o: |-> commit column proVlanStatus.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_VLANSTS;
		//iValue.integer = rowreq_ctx->data.proVlanStatus;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proVlanStatus )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proVlanStatus commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proVlanStatus
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROVLANSTATUS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH1VID_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH1VID_FLAG; /* clear proEth1vid */
	       /*
	        * TODO:482:o: |-> commit column proEth1vid.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH1VID;
		iValue.integer = rowreq_ctx->data.proEth1vid;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth1vid commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth1vid
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH1VID_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH2VID_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH2VID_FLAG; /* clear proEth2vid */
	       /*
	        * TODO:482:o: |-> commit column proEth2vid.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH2VID;
		iValue.integer = rowreq_ctx->data.proEth2vid;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth2vid commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth2vid
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH2VID_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH3VID_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH3VID_FLAG; /* clear proEth3vid */
	       /*
	        * TODO:482:o: |-> commit column proEth3vid.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH3VID;
		iValue.integer = rowreq_ctx->data.proEth3vid;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth3vid commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth3vid
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH3VID_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH4VID_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH4VID_FLAG; /* clear proEth4vid */
	       /*
	        * TODO:482:o: |-> commit column proEth4vid.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH4VID;
		iValue.integer = rowreq_ctx->data.proEth4vid;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth4vid commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth4vid
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH4VID_FLAG;
		}
	}

	if (save_flags & COLUMN_PROPORTPRISTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROPORTPRISTS_FLAG; /* clear proPortPriSts */
	       /*
	        * TODO:482:o: |-> commit column proPortPriSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_PORTPRISTS;
		//iValue.integer = rowreq_ctx->data.proPortPriSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proPortPriSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proPortPriSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proPortPriSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROPORTPRISTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH1PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH1PRI_FLAG; /* clear proEth1pri */
	       /*
	        * TODO:482:o: |-> commit column proEth1pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH1PRI;
		iValue.integer = rowreq_ctx->data.proEth1pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth1pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth1pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH1PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH2PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH2PRI_FLAG; /* clear proEth2pri */
	       /*
	        * TODO:482:o: |-> commit column proEth2pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH2PRI;
		iValue.integer = rowreq_ctx->data.proEth2pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth2pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth2pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH2PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH3PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH3PRI_FLAG; /* clear proEth3pri */
	       /*
	        * TODO:482:o: |-> commit column proEth3pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH3PRI;
		iValue.integer = rowreq_ctx->data.proEth3pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth3pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth3pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH3PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH4PRI_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH4PRI_FLAG; /* clear proEth4pri */
	       /*
	        * TODO:482:o: |-> commit column proEth4pri.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH4PRI;
		iValue.integer = rowreq_ctx->data.proEth4pri;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth4pri commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth4pri
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH4PRI_FLAG;
		}
	}

	if (save_flags & COLUMN_PRORXLIMITSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PRORXLIMITSTS_FLAG; /* clear proRxLimitSts */
	       /*
	        * TODO:482:o: |-> commit column proRxLimitSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_RXLIMITSTS;
		//iValue.integer = rowreq_ctx->data.proRxLimitSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proRxLimitSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proRxLimitSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proRxLimitSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PRORXLIMITSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCPUPORTRXRATE_FLAG)
	{
	       save_flags &= ~COLUMN_PROCPUPORTRXRATE_FLAG; /* clear proCpuPortRxRate */
	       /*
	        * TODO:482:o: |-> commit column proCpuPortRxRate.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_CPURX;
		iValue.integer = rowreq_ctx->data.proCpuPortRxRate;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCpuPortRxRate commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCpuPortRxRate
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCPUPORTRXRATE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH1RX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH1RX_FLAG; /* clear proEth1rx */
	       /*
	        * TODO:482:o: |-> commit column proEth1rx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH1RX;
		iValue.integer = rowreq_ctx->data.proEth1rx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth1rx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth1rx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH1RX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH2RX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH2RX_FLAG; /* clear proEth2rx */
	       /*
	        * TODO:482:o: |-> commit column proEth2rx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH2RX;
		iValue.integer = rowreq_ctx->data.proEth2rx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth2rx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth2rx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH2RX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH3RX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH3RX_FLAG; /* clear proEth3rx */
	       /*
	        * TODO:482:o: |-> commit column proEth3rx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH3RX;
		iValue.integer = rowreq_ctx->data.proEth3rx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth3rx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth3rx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH3RX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH4RX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH4RX_FLAG; /* clear proEth4rx */
	       /*
	        * TODO:482:o: |-> commit column proEth4rx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH4RX;
		iValue.integer = rowreq_ctx->data.proEth4rx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth4rx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth4rx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH4RX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROTXLIMITSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROTXLIMITSTS_FLAG; /* clear proTxLimitSts */
	       /*
	        * TODO:482:o: |-> commit column proTxLimitSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_TXLIMITSTS;
		//iValue.integer = rowreq_ctx->data.proTxLimitSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proTxLimitSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proTxLimitSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proTxLimitSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROTXLIMITSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCPUPORTTXRATE_FLAG)
	{
	       save_flags &= ~COLUMN_PROCPUPORTTXRATE_FLAG; /* clear proCpuPortTxRate */
	       /*
	        * TODO:482:o: |-> commit column proCpuPortTxRate.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_CPUTX;
		iValue.integer = rowreq_ctx->data.proCpuPortTxRate;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proCpuPortTxRate commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proCpuPortTxRate
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROCPUPORTTXRATE_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH1TX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH1TX_FLAG; /* clear proEth1tx */
	       /*
	        * TODO:482:o: |-> commit column proEth1tx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH1TX;
		iValue.integer = rowreq_ctx->data.proEth1tx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth1tx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth1tx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH1TX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH2TX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH2TX_FLAG; /* clear proEth2tx */
	       /*
	        * TODO:482:o: |-> commit column proEth2tx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH2TX;
		iValue.integer = rowreq_ctx->data.proEth2tx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth2tx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth2tx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH2TX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH3TX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH3TX_FLAG; /* clear proEth3tx */
	       /*
	        * TODO:482:o: |-> commit column proEth3tx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH3TX;
		iValue.integer = rowreq_ctx->data.proEth3tx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth3tx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth3tx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH3TX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH4TX_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH4TX_FLAG; /* clear proEth4tx */
	       /*
	        * TODO:482:o: |-> commit column proEth4tx.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH4TX;
		iValue.integer = rowreq_ctx->data.proEth4tx;
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth4tx commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth4tx
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH4TX_FLAG;
		}
	}

	if (save_flags & COLUMN_PROPSCTLSTS_FLAG)
	{
	       save_flags &= ~COLUMN_PROPSCTLSTS_FLAG; /* clear proPsctlSts */
	       /*
	        * TODO:482:o: |-> commit column proPsctlSts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_PSCTL;
		//iValue.integer = rowreq_ctx->data.proPsctlSts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proPsctlSts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proPsctlSts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proPsctlSts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROPSCTLSTS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH1STS_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH1STS_FLAG; /* clear proEth1sts */
	       /*
	        * TODO:482:o: |-> commit column proEth1sts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH1STS;
		//iValue.integer = rowreq_ctx->data.proEth1sts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proEth1sts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth1sts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth1sts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH1STS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH2STS_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH2STS_FLAG; /* clear proEth2sts */
	       /*
	        * TODO:482:o: |-> commit column proEth2sts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH2STS;
		//iValue.integer = rowreq_ctx->data.proEth2sts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proEth2sts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth2sts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth2sts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH2STS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH3STS_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH3STS_FLAG; /* clear proEth3sts */
	       /*
	        * TODO:482:o: |-> commit column proEth3sts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH3STS;
		//iValue.integer = rowreq_ctx->data.proEth3sts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proEth3sts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth3sts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth3sts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH3STS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROETH4STS_FLAG)
	{
	       save_flags &= ~COLUMN_PROETH4STS_FLAG; /* clear proEth4sts */
	       /*
	        * TODO:482:o: |-> commit column proEth4sts.
	        */
	       /* Modified by frank */
		iValue.ci.col = DBS_SYS_TBL_PROFILE_COL_ID_ETH4STS;
		//iValue.integer = rowreq_ctx->data.proEth4sts;
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proEth4sts )
		{
			iValue.integer = 1;
		}
		else
		{
			iValue.integer = 0;
		}
		
		if( CMM_SUCCESS != dbsUpdateInteger(dbsdev, &iValue) )
		{
			rc = -1;
			snmp_log(LOG_ERR,"profileTable column proEth4sts commit failed\n");
		}
		else
		{
			/*
			* set flag, in case we need to undo proEth4sts
			*/
			rc = 0;
			rowreq_ctx->column_set_flags |= COLUMN_PROETH4STS_FLAG;
		}
	}

	if (save_flags & COLUMN_PROCOMMIT_FLAG)
	{
	       save_flags &= ~COLUMN_PROCOMMIT_FLAG; /* clear proCommit */
		/*
		* TODO:482:o: |-> commit column proCommit.
		*/
	        /* modified by frank */
		if( TRUTHVALUE_TRUE == rowreq_ctx->data.proCommit )
		{
			if( CMM_SUCCESS != snmp2cmm_reloadCnuProfile(rowreq_ctx->data.proIndex) )
			{
				rc = -1;
				snmp_log(LOG_ERR,"profileTable column proCommit commit failed\n");
			}
			else
			{
				rc = 0;
				/*
				* set flag, in case we need to undo proCommit
				*/
				rowreq_ctx->column_set_flags |= COLUMN_PROCOMMIT_FLAG;	
			}
		}
		else
		{
			rc = 0;
		}       	
	}

	/*
	* if we successfully commited this row, set the dirty flag.
	*/
	if (MFD_SUCCESS == rc)
	{
		rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
	}

	if (save_flags)
	{
		snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
		return MFD_ERROR;
	}

	return rc;
} /* profileTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * profileTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param profileTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
profileTable_undo_commit( profileTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:profileTable:profileTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo profileTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* profileTable_undo_commit */

/*
 * TODO:440:M: Implement profileTable node value checks.
 * TODO:450:M: Implement profileTable undo functions.
 * TODO:460:M: Implement profileTable set functions.
 * TODO:480:M: Implement profileTable commit functions.
 */
/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proBase
 * proBase is subid 3 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.3
 * Description:
atheros eoc pib index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 32;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proBase_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 32
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proBase_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proBase_val)
{
    DEBUGMSGTL(("verbose:profileTable:proBase_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proBase value.
     */

    return MFD_SUCCESS; /* proBase value not illegal */
} /* proBase_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proBase_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proBase_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proBase undo.
     */
    /*
     * copy proBase data
     * set rowreq_ctx->undo->proBase from rowreq_ctx->data.proBase
     */
    rowreq_ctx->undo->proBase = rowreq_ctx->data.proBase;


    return MFD_SUCCESS;
} /* proBase_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proBase_val
 *        A long containing the new value.
 */
int
proBase_set( profileTable_rowreq_ctx *rowreq_ctx, long proBase_val )
{

    DEBUGMSGTL(("verbose:profileTable:proBase_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proBase value.
     * set proBase value in rowreq_ctx->data
     */
    rowreq_ctx->data.proBase = proBase_val;

    return MFD_SUCCESS;
} /* proBase_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proBase_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proBase_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proBase undo.
     */
    /*
     * copy proBase data
     * set rowreq_ctx->data.proBase from rowreq_ctx->undo->proBase
     */
    rowreq_ctx->data.proBase = rowreq_ctx->undo->proBase;

    
    return MFD_SUCCESS;
} /* proBase_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proMacLimit
 * proMacLimit is subid 4 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.4
 * Description:
EoC bridged hosts limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 8/16. Values:  hosts_limiting_disabled(0), one_host(1), two_hosts(2), three_hosts(3), four_hosts(4), five_hosts(5), six_hosts(6), seven_hosts(7), eight_hosts(8), null_hosts(65)
 *
 * Its syntax is HostsLimitingValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proMacLimit_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  hosts_limiting_disabled(0), one_host(1), two_hosts(2), three_hosts(3), four_hosts(4), five_hosts(5), six_hosts(6), seven_hosts(7), eight_hosts(8), null_hosts(65)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proMacLimit_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proMacLimit_val)
{
    DEBUGMSGTL(("verbose:profileTable:proMacLimit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proMacLimit value.
     */

    return MFD_SUCCESS; /* proMacLimit value not illegal */
} /* proMacLimit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proMacLimit_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proMacLimit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proMacLimit undo.
     */
    /*
     * copy proMacLimit data
     * set rowreq_ctx->undo->proMacLimit from rowreq_ctx->data.proMacLimit
     */
    rowreq_ctx->undo->proMacLimit = rowreq_ctx->data.proMacLimit;


    return MFD_SUCCESS;
} /* proMacLimit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proMacLimit_val
 *        A long containing the new value.
 */
int
proMacLimit_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proMacLimit_val )
{

    DEBUGMSGTL(("verbose:profileTable:proMacLimit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proMacLimit value.
     * set proMacLimit value in rowreq_ctx->data
     */
    rowreq_ctx->data.proMacLimit = proMacLimit_val;

    return MFD_SUCCESS;
} /* proMacLimit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proMacLimit_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proMacLimit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proMacLimit undo.
     */
    /*
     * copy proMacLimit data
     * set rowreq_ctx->data.proMacLimit from rowreq_ctx->undo->proMacLimit
     */
    rowreq_ctx->data.proMacLimit = rowreq_ctx->undo->proMacLimit;

    
    return MFD_SUCCESS;
} /* proMacLimit_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCableUplinkRate
 * proCableUplinkRate is subid 5 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.5
 * Description:
Cable uplink rate limiting in kbps.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCableUplinkRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCableUplinkRate_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proCableUplinkRate_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCableUplinkRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCableUplinkRate value.
     */

    return MFD_SUCCESS; /* proCableUplinkRate value not illegal */
} /* proCableUplinkRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCableUplinkRate_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCableUplinkRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCableUplinkRate undo.
     */
    /*
     * copy proCableUplinkRate data
     * set rowreq_ctx->undo->proCableUplinkRate from rowreq_ctx->data.proCableUplinkRate
     */
    rowreq_ctx->undo->proCableUplinkRate = rowreq_ctx->data.proCableUplinkRate;


    return MFD_SUCCESS;
} /* proCableUplinkRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCableUplinkRate_val
 *        A long containing the new value.
 */
int
proCableUplinkRate_set( profileTable_rowreq_ctx *rowreq_ctx, long proCableUplinkRate_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCableUplinkRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCableUplinkRate value.
     * set proCableUplinkRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCableUplinkRate = proCableUplinkRate_val;

    return MFD_SUCCESS;
} /* proCableUplinkRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCableUplinkRate_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCableUplinkRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCableUplinkRate undo.
     */
    /*
     * copy proCableUplinkRate data
     * set rowreq_ctx->data.proCableUplinkRate from rowreq_ctx->undo->proCableUplinkRate
     */
    rowreq_ctx->data.proCableUplinkRate = rowreq_ctx->undo->proCableUplinkRate;

    
    return MFD_SUCCESS;
} /* proCableUplinkRate_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCableDownlinkRate
 * proCableDownlinkRate is subid 6 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.6
 * Description:
Cable downlink rate limiting in kbps.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCableDownlinkRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCableDownlinkRate_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proCableDownlinkRate_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCableDownlinkRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCableDownlinkRate value.
     */

    return MFD_SUCCESS; /* proCableDownlinkRate value not illegal */
} /* proCableDownlinkRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCableDownlinkRate_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCableDownlinkRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCableDownlinkRate undo.
     */
    /*
     * copy proCableDownlinkRate data
     * set rowreq_ctx->undo->proCableDownlinkRate from rowreq_ctx->data.proCableDownlinkRate
     */
    rowreq_ctx->undo->proCableDownlinkRate = rowreq_ctx->data.proCableDownlinkRate;


    return MFD_SUCCESS;
} /* proCableDownlinkRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCableDownlinkRate_val
 *        A long containing the new value.
 */
int
proCableDownlinkRate_set( profileTable_rowreq_ctx *rowreq_ctx, long proCableDownlinkRate_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCableDownlinkRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCableDownlinkRate value.
     * set proCableDownlinkRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCableDownlinkRate = proCableDownlinkRate_val;

    return MFD_SUCCESS;
} /* proCableDownlinkRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCableDownlinkRate_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCableDownlinkRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCableDownlinkRate undo.
     */
    /*
     * copy proCableDownlinkRate data
     * set rowreq_ctx->data.proCableDownlinkRate from rowreq_ctx->undo->proCableDownlinkRate
     */
    rowreq_ctx->data.proCableDownlinkRate = rowreq_ctx->undo->proCableDownlinkRate;

    
    return MFD_SUCCESS;
} /* proCableDownlinkRate_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proLocalAgingTime
 * proLocalAgingTime is subid 7 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.7
 * Description:
Local bridge aging time in minutes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proLocalAgingTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proLocalAgingTime_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proLocalAgingTime_val)
{
    DEBUGMSGTL(("verbose:profileTable:proLocalAgingTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proLocalAgingTime value.
     */

    return MFD_SUCCESS; /* proLocalAgingTime value not illegal */
} /* proLocalAgingTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proLocalAgingTime_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proLocalAgingTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proLocalAgingTime undo.
     */
    /*
     * copy proLocalAgingTime data
     * set rowreq_ctx->undo->proLocalAgingTime from rowreq_ctx->data.proLocalAgingTime
     */
    rowreq_ctx->undo->proLocalAgingTime = rowreq_ctx->data.proLocalAgingTime;


    return MFD_SUCCESS;
} /* proLocalAgingTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proLocalAgingTime_val
 *        A long containing the new value.
 */
int
proLocalAgingTime_set( profileTable_rowreq_ctx *rowreq_ctx, long proLocalAgingTime_val )
{

    DEBUGMSGTL(("verbose:profileTable:proLocalAgingTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proLocalAgingTime value.
     * set proLocalAgingTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.proLocalAgingTime = proLocalAgingTime_val;

    return MFD_SUCCESS;
} /* proLocalAgingTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proLocalAgingTime_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proLocalAgingTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proLocalAgingTime undo.
     */
    /*
     * copy proLocalAgingTime data
     * set rowreq_ctx->data.proLocalAgingTime from rowreq_ctx->undo->proLocalAgingTime
     */
    rowreq_ctx->data.proLocalAgingTime = rowreq_ctx->undo->proLocalAgingTime;

    
    return MFD_SUCCESS;
} /* proLocalAgingTime_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proRemoteAgingTime
 * proRemoteAgingTime is subid 8 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.8
 * Description:
Remote devie bridge table aging time in minutes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proRemoteAgingTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proRemoteAgingTime_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proRemoteAgingTime_val)
{
    DEBUGMSGTL(("verbose:profileTable:proRemoteAgingTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proRemoteAgingTime value.
     */

    return MFD_SUCCESS; /* proRemoteAgingTime value not illegal */
} /* proRemoteAgingTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proRemoteAgingTime_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proRemoteAgingTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proRemoteAgingTime undo.
     */
    /*
     * copy proRemoteAgingTime data
     * set rowreq_ctx->undo->proRemoteAgingTime from rowreq_ctx->data.proRemoteAgingTime
     */
    rowreq_ctx->undo->proRemoteAgingTime = rowreq_ctx->data.proRemoteAgingTime;


    return MFD_SUCCESS;
} /* proRemoteAgingTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proRemoteAgingTime_val
 *        A long containing the new value.
 */
int
proRemoteAgingTime_set( profileTable_rowreq_ctx *rowreq_ctx, long proRemoteAgingTime_val )
{

    DEBUGMSGTL(("verbose:profileTable:proRemoteAgingTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proRemoteAgingTime value.
     * set proRemoteAgingTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.proRemoteAgingTime = proRemoteAgingTime_val;

    return MFD_SUCCESS;
} /* proRemoteAgingTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proRemoteAgingTime_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proRemoteAgingTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proRemoteAgingTime undo.
     */
    /*
     * copy proRemoteAgingTime data
     * set rowreq_ctx->data.proRemoteAgingTime from rowreq_ctx->undo->proRemoteAgingTime
     */
    rowreq_ctx->data.proRemoteAgingTime = rowreq_ctx->undo->proRemoteAgingTime;

    
    return MFD_SUCCESS;
} /* proRemoteAgingTime_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proIgmpPri
 * proIgmpPri is subid 9 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.9
 * Description:
IGMP Priority CAP value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proIgmpPri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proIgmpPri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proIgmpPri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proIgmpPri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proIgmpPri value.
     */

    return MFD_SUCCESS; /* proIgmpPri value not illegal */
} /* proIgmpPri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proIgmpPri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proIgmpPri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proIgmpPri undo.
     */
    /*
     * copy proIgmpPri data
     * set rowreq_ctx->undo->proIgmpPri from rowreq_ctx->data.proIgmpPri
     */
    rowreq_ctx->undo->proIgmpPri = rowreq_ctx->data.proIgmpPri;


    return MFD_SUCCESS;
} /* proIgmpPri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proIgmpPri_val
 *        A long containing the new value.
 */
int
proIgmpPri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proIgmpPri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proIgmpPri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proIgmpPri value.
     * set proIgmpPri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proIgmpPri = proIgmpPri_val;

    return MFD_SUCCESS;
} /* proIgmpPri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proIgmpPri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proIgmpPri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proIgmpPri undo.
     */
    /*
     * copy proIgmpPri data
     * set rowreq_ctx->data.proIgmpPri from rowreq_ctx->undo->proIgmpPri
     */
    rowreq_ctx->data.proIgmpPri = rowreq_ctx->undo->proIgmpPri;

    
    return MFD_SUCCESS;
} /* proIgmpPri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proUnicastPri
 * proUnicastPri is subid 10 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.10
 * Description:
Unicast Priority CAP value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proUnicastPri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proUnicastPri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proUnicastPri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proUnicastPri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proUnicastPri value.
     */

    return MFD_SUCCESS; /* proUnicastPri value not illegal */
} /* proUnicastPri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proUnicastPri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proUnicastPri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proUnicastPri undo.
     */
    /*
     * copy proUnicastPri data
     * set rowreq_ctx->undo->proUnicastPri from rowreq_ctx->data.proUnicastPri
     */
    rowreq_ctx->undo->proUnicastPri = rowreq_ctx->data.proUnicastPri;


    return MFD_SUCCESS;
} /* proUnicastPri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proUnicastPri_val
 *        A long containing the new value.
 */
int
proUnicastPri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proUnicastPri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proUnicastPri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proUnicastPri value.
     * set proUnicastPri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proUnicastPri = proUnicastPri_val;

    return MFD_SUCCESS;
} /* proUnicastPri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proUnicastPri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proUnicastPri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proUnicastPri undo.
     */
    /*
     * copy proUnicastPri data
     * set rowreq_ctx->data.proUnicastPri from rowreq_ctx->undo->proUnicastPri
     */
    rowreq_ctx->data.proUnicastPri = rowreq_ctx->undo->proUnicastPri;

    
    return MFD_SUCCESS;
} /* proUnicastPri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proAvsPri
 * proAvsPri is subid 11 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.11
 * Description:
AV Stream Priority CAP value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proAvsPri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proAvsPri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proAvsPri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proAvsPri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proAvsPri value.
     */

    return MFD_SUCCESS; /* proAvsPri value not illegal */
} /* proAvsPri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proAvsPri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proAvsPri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proAvsPri undo.
     */
    /*
     * copy proAvsPri data
     * set rowreq_ctx->undo->proAvsPri from rowreq_ctx->data.proAvsPri
     */
    rowreq_ctx->undo->proAvsPri = rowreq_ctx->data.proAvsPri;


    return MFD_SUCCESS;
} /* proAvsPri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proAvsPri_val
 *        A long containing the new value.
 */
int
proAvsPri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proAvsPri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proAvsPri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proAvsPri value.
     * set proAvsPri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proAvsPri = proAvsPri_val;

    return MFD_SUCCESS;
} /* proAvsPri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proAvsPri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proAvsPri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proAvsPri undo.
     */
    /*
     * copy proAvsPri data
     * set rowreq_ctx->data.proAvsPri from rowreq_ctx->undo->proAvsPri
     */
    rowreq_ctx->data.proAvsPri = rowreq_ctx->undo->proAvsPri;

    
    return MFD_SUCCESS;
} /* proAvsPri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proMcastPri
 * proMcastPri is subid 12 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.12
 * Description:
Multicast Priority CAP value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proMcastPri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proMcastPri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proMcastPri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proMcastPri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proMcastPri value.
     */

    return MFD_SUCCESS; /* proMcastPri value not illegal */
} /* proMcastPri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proMcastPri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proMcastPri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proMcastPri undo.
     */
    /*
     * copy proMcastPri data
     * set rowreq_ctx->undo->proMcastPri from rowreq_ctx->data.proMcastPri
     */
    rowreq_ctx->undo->proMcastPri = rowreq_ctx->data.proMcastPri;


    return MFD_SUCCESS;
} /* proMcastPri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proMcastPri_val
 *        A long containing the new value.
 */
int
proMcastPri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proMcastPri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proMcastPri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proMcastPri value.
     * set proMcastPri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proMcastPri = proMcastPri_val;

    return MFD_SUCCESS;
} /* proMcastPri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proMcastPri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proMcastPri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proMcastPri undo.
     */
    /*
     * copy proMcastPri data
     * set rowreq_ctx->data.proMcastPri from rowreq_ctx->undo->proMcastPri
     */
    rowreq_ctx->data.proMcastPri = rowreq_ctx->undo->proMcastPri;

    
    return MFD_SUCCESS;
} /* proMcastPri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTbaPriSts
 * proTbaPriSts is subid 13 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.13
 * Description:
TX buffer based on priority status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTbaPriSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTbaPriSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTbaPriSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTbaPriSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTbaPriSts value.
     */

    return MFD_SUCCESS; /* proTbaPriSts value not illegal */
} /* proTbaPriSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTbaPriSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTbaPriSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTbaPriSts undo.
     */
    /*
     * copy proTbaPriSts data
     * set rowreq_ctx->undo->proTbaPriSts from rowreq_ctx->data.proTbaPriSts
     */
    rowreq_ctx->undo->proTbaPriSts = rowreq_ctx->data.proTbaPriSts;


    return MFD_SUCCESS;
} /* proTbaPriSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTbaPriSts_val
 *        A long containing the new value.
 */
int
proTbaPriSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTbaPriSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTbaPriSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTbaPriSts value.
     * set proTbaPriSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTbaPriSts = proTbaPriSts_val;

    return MFD_SUCCESS;
} /* proTbaPriSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTbaPriSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTbaPriSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTbaPriSts undo.
     */
    /*
     * copy proTbaPriSts data
     * set rowreq_ctx->data.proTbaPriSts from rowreq_ctx->undo->proTbaPriSts
     */
    rowreq_ctx->data.proTbaPriSts = rowreq_ctx->undo->proTbaPriSts;

    
    return MFD_SUCCESS;
} /* proTbaPriSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCosPriSts
 * proCosPriSts is subid 14 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.14
 * Description:
Map VLAN to Priority CAP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCosPriSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCosPriSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCosPriSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCosPriSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCosPriSts value.
     */

    return MFD_SUCCESS; /* proCosPriSts value not illegal */
} /* proCosPriSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCosPriSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCosPriSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCosPriSts undo.
     */
    /*
     * copy proCosPriSts data
     * set rowreq_ctx->undo->proCosPriSts from rowreq_ctx->data.proCosPriSts
     */
    rowreq_ctx->undo->proCosPriSts = rowreq_ctx->data.proCosPriSts;


    return MFD_SUCCESS;
} /* proCosPriSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCosPriSts_val
 *        A long containing the new value.
 */
int
proCosPriSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCosPriSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCosPriSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCosPriSts value.
     * set proCosPriSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCosPriSts = proCosPriSts_val;

    return MFD_SUCCESS;
} /* proCosPriSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCosPriSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCosPriSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCosPriSts undo.
     */
    /*
     * copy proCosPriSts data
     * set rowreq_ctx->data.proCosPriSts from rowreq_ctx->undo->proCosPriSts
     */
    rowreq_ctx->data.proCosPriSts = rowreq_ctx->undo->proCosPriSts;

    
    return MFD_SUCCESS;
} /* proCosPriSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos0pri
 * proCos0pri is subid 15 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.15
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos0pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos0pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos0pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos0pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos0pri value.
     */

    return MFD_SUCCESS; /* proCos0pri value not illegal */
} /* proCos0pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos0pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos0pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos0pri undo.
     */
    /*
     * copy proCos0pri data
     * set rowreq_ctx->undo->proCos0pri from rowreq_ctx->data.proCos0pri
     */
    rowreq_ctx->undo->proCos0pri = rowreq_ctx->data.proCos0pri;


    return MFD_SUCCESS;
} /* proCos0pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos0pri_val
 *        A long containing the new value.
 */
int
proCos0pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos0pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos0pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos0pri value.
     * set proCos0pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos0pri = proCos0pri_val;

    return MFD_SUCCESS;
} /* proCos0pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos0pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos0pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos0pri undo.
     */
    /*
     * copy proCos0pri data
     * set rowreq_ctx->data.proCos0pri from rowreq_ctx->undo->proCos0pri
     */
    rowreq_ctx->data.proCos0pri = rowreq_ctx->undo->proCos0pri;

    
    return MFD_SUCCESS;
} /* proCos0pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos1pri
 * proCos1pri is subid 16 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.16
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos1pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos1pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos1pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos1pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos1pri value.
     */

    return MFD_SUCCESS; /* proCos1pri value not illegal */
} /* proCos1pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos1pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos1pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos1pri undo.
     */
    /*
     * copy proCos1pri data
     * set rowreq_ctx->undo->proCos1pri from rowreq_ctx->data.proCos1pri
     */
    rowreq_ctx->undo->proCos1pri = rowreq_ctx->data.proCos1pri;


    return MFD_SUCCESS;
} /* proCos1pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos1pri_val
 *        A long containing the new value.
 */
int
proCos1pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos1pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos1pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos1pri value.
     * set proCos1pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos1pri = proCos1pri_val;

    return MFD_SUCCESS;
} /* proCos1pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos1pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos1pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos1pri undo.
     */
    /*
     * copy proCos1pri data
     * set rowreq_ctx->data.proCos1pri from rowreq_ctx->undo->proCos1pri
     */
    rowreq_ctx->data.proCos1pri = rowreq_ctx->undo->proCos1pri;

    
    return MFD_SUCCESS;
} /* proCos1pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos2pri
 * proCos2pri is subid 17 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.17
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos2pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos2pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos2pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos2pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos2pri value.
     */

    return MFD_SUCCESS; /* proCos2pri value not illegal */
} /* proCos2pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos2pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos2pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos2pri undo.
     */
    /*
     * copy proCos2pri data
     * set rowreq_ctx->undo->proCos2pri from rowreq_ctx->data.proCos2pri
     */
    rowreq_ctx->undo->proCos2pri = rowreq_ctx->data.proCos2pri;


    return MFD_SUCCESS;
} /* proCos2pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos2pri_val
 *        A long containing the new value.
 */
int
proCos2pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos2pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos2pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos2pri value.
     * set proCos2pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos2pri = proCos2pri_val;

    return MFD_SUCCESS;
} /* proCos2pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos2pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos2pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos2pri undo.
     */
    /*
     * copy proCos2pri data
     * set rowreq_ctx->data.proCos2pri from rowreq_ctx->undo->proCos2pri
     */
    rowreq_ctx->data.proCos2pri = rowreq_ctx->undo->proCos2pri;

    
    return MFD_SUCCESS;
} /* proCos2pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos3pri
 * proCos3pri is subid 18 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.18
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos3pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos3pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos3pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos3pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos3pri value.
     */

    return MFD_SUCCESS; /* proCos3pri value not illegal */
} /* proCos3pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos3pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos3pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos3pri undo.
     */
    /*
     * copy proCos3pri data
     * set rowreq_ctx->undo->proCos3pri from rowreq_ctx->data.proCos3pri
     */
    rowreq_ctx->undo->proCos3pri = rowreq_ctx->data.proCos3pri;


    return MFD_SUCCESS;
} /* proCos3pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos3pri_val
 *        A long containing the new value.
 */
int
proCos3pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos3pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos3pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos3pri value.
     * set proCos3pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos3pri = proCos3pri_val;

    return MFD_SUCCESS;
} /* proCos3pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos3pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos3pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos3pri undo.
     */
    /*
     * copy proCos3pri data
     * set rowreq_ctx->data.proCos3pri from rowreq_ctx->undo->proCos3pri
     */
    rowreq_ctx->data.proCos3pri = rowreq_ctx->undo->proCos3pri;

    
    return MFD_SUCCESS;
} /* proCos3pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos4pri
 * proCos4pri is subid 19 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.19
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos4pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos4pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos4pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos4pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos4pri value.
     */

    return MFD_SUCCESS; /* proCos4pri value not illegal */
} /* proCos4pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos4pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos4pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos4pri undo.
     */
    /*
     * copy proCos4pri data
     * set rowreq_ctx->undo->proCos4pri from rowreq_ctx->data.proCos4pri
     */
    rowreq_ctx->undo->proCos4pri = rowreq_ctx->data.proCos4pri;


    return MFD_SUCCESS;
} /* proCos4pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos4pri_val
 *        A long containing the new value.
 */
int
proCos4pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos4pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos4pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos4pri value.
     * set proCos4pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos4pri = proCos4pri_val;

    return MFD_SUCCESS;
} /* proCos4pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos4pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos4pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos4pri undo.
     */
    /*
     * copy proCos4pri data
     * set rowreq_ctx->data.proCos4pri from rowreq_ctx->undo->proCos4pri
     */
    rowreq_ctx->data.proCos4pri = rowreq_ctx->undo->proCos4pri;

    
    return MFD_SUCCESS;
} /* proCos4pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos5pri
 * proCos5pri is subid 20 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.20
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos5pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos5pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos5pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos5pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos5pri value.
     */

    return MFD_SUCCESS; /* proCos5pri value not illegal */
} /* proCos5pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos5pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos5pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos5pri undo.
     */
    /*
     * copy proCos5pri data
     * set rowreq_ctx->undo->proCos5pri from rowreq_ctx->data.proCos5pri
     */
    rowreq_ctx->undo->proCos5pri = rowreq_ctx->data.proCos5pri;


    return MFD_SUCCESS;
} /* proCos5pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos5pri_val
 *        A long containing the new value.
 */
int
proCos5pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos5pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos5pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos5pri value.
     * set proCos5pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos5pri = proCos5pri_val;

    return MFD_SUCCESS;
} /* proCos5pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos5pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos5pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos5pri undo.
     */
    /*
     * copy proCos5pri data
     * set rowreq_ctx->data.proCos5pri from rowreq_ctx->undo->proCos5pri
     */
    rowreq_ctx->data.proCos5pri = rowreq_ctx->undo->proCos5pri;

    
    return MFD_SUCCESS;
} /* proCos5pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos6pri
 * proCos6pri is subid 21 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.21
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos6pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos6pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos6pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos6pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos6pri value.
     */

    return MFD_SUCCESS; /* proCos6pri value not illegal */
} /* proCos6pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos6pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos6pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos6pri undo.
     */
    /*
     * copy proCos6pri data
     * set rowreq_ctx->undo->proCos6pri from rowreq_ctx->data.proCos6pri
     */
    rowreq_ctx->undo->proCos6pri = rowreq_ctx->data.proCos6pri;


    return MFD_SUCCESS;
} /* proCos6pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos6pri_val
 *        A long containing the new value.
 */
int
proCos6pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos6pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos6pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos6pri value.
     * set proCos6pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos6pri = proCos6pri_val;

    return MFD_SUCCESS;
} /* proCos6pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos6pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos6pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos6pri undo.
     */
    /*
     * copy proCos6pri data
     * set rowreq_ctx->data.proCos6pri from rowreq_ctx->undo->proCos6pri
     */
    rowreq_ctx->data.proCos6pri = rowreq_ctx->undo->proCos6pri;

    
    return MFD_SUCCESS;
} /* proCos6pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCos7pri
 * proCos7pri is subid 22 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.22
 * Description:
VLAN priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCos7pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCos7pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos7pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCos7pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCos7pri value.
     */

    return MFD_SUCCESS; /* proCos7pri value not illegal */
} /* proCos7pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCos7pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCos7pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCos7pri undo.
     */
    /*
     * copy proCos7pri data
     * set rowreq_ctx->undo->proCos7pri from rowreq_ctx->data.proCos7pri
     */
    rowreq_ctx->undo->proCos7pri = rowreq_ctx->data.proCos7pri;


    return MFD_SUCCESS;
} /* proCos7pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCos7pri_val
 *        A long containing the new value.
 */
int
proCos7pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCos7pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCos7pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCos7pri value.
     * set proCos7pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCos7pri = proCos7pri_val;

    return MFD_SUCCESS;
} /* proCos7pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCos7pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCos7pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCos7pri undo.
     */
    /*
     * copy proCos7pri data
     * set rowreq_ctx->data.proCos7pri from rowreq_ctx->undo->proCos7pri
     */
    rowreq_ctx->data.proCos7pri = rowreq_ctx->undo->proCos7pri;

    
    return MFD_SUCCESS;
} /* proCos7pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTosPriSts
 * proTosPriSts is subid 23 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.23
 * Description:
Map TOS to Priority CAP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTosPriSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTosPriSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTosPriSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTosPriSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTosPriSts value.
     */

    return MFD_SUCCESS; /* proTosPriSts value not illegal */
} /* proTosPriSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTosPriSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTosPriSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTosPriSts undo.
     */
    /*
     * copy proTosPriSts data
     * set rowreq_ctx->undo->proTosPriSts from rowreq_ctx->data.proTosPriSts
     */
    rowreq_ctx->undo->proTosPriSts = rowreq_ctx->data.proTosPriSts;


    return MFD_SUCCESS;
} /* proTosPriSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTosPriSts_val
 *        A long containing the new value.
 */
int
proTosPriSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTosPriSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTosPriSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTosPriSts value.
     * set proTosPriSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTosPriSts = proTosPriSts_val;

    return MFD_SUCCESS;
} /* proTosPriSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTosPriSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTosPriSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTosPriSts undo.
     */
    /*
     * copy proTosPriSts data
     * set rowreq_ctx->data.proTosPriSts from rowreq_ctx->undo->proTosPriSts
     */
    rowreq_ctx->data.proTosPriSts = rowreq_ctx->undo->proTosPriSts;

    
    return MFD_SUCCESS;
} /* proTosPriSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos0pri
 * proTos0pri is subid 24 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.24
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos0pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos0pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos0pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos0pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos0pri value.
     */

    return MFD_SUCCESS; /* proTos0pri value not illegal */
} /* proTos0pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos0pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos0pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos0pri undo.
     */
    /*
     * copy proTos0pri data
     * set rowreq_ctx->undo->proTos0pri from rowreq_ctx->data.proTos0pri
     */
    rowreq_ctx->undo->proTos0pri = rowreq_ctx->data.proTos0pri;


    return MFD_SUCCESS;
} /* proTos0pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos0pri_val
 *        A long containing the new value.
 */
int
proTos0pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos0pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos0pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos0pri value.
     * set proTos0pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos0pri = proTos0pri_val;

    return MFD_SUCCESS;
} /* proTos0pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos0pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos0pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos0pri undo.
     */
    /*
     * copy proTos0pri data
     * set rowreq_ctx->data.proTos0pri from rowreq_ctx->undo->proTos0pri
     */
    rowreq_ctx->data.proTos0pri = rowreq_ctx->undo->proTos0pri;

    
    return MFD_SUCCESS;
} /* proTos0pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos1pri
 * proTos1pri is subid 25 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.25
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos1pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos1pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos1pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos1pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos1pri value.
     */

    return MFD_SUCCESS; /* proTos1pri value not illegal */
} /* proTos1pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos1pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos1pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos1pri undo.
     */
    /*
     * copy proTos1pri data
     * set rowreq_ctx->undo->proTos1pri from rowreq_ctx->data.proTos1pri
     */
    rowreq_ctx->undo->proTos1pri = rowreq_ctx->data.proTos1pri;


    return MFD_SUCCESS;
} /* proTos1pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos1pri_val
 *        A long containing the new value.
 */
int
proTos1pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos1pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos1pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos1pri value.
     * set proTos1pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos1pri = proTos1pri_val;

    return MFD_SUCCESS;
} /* proTos1pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos1pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos1pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos1pri undo.
     */
    /*
     * copy proTos1pri data
     * set rowreq_ctx->data.proTos1pri from rowreq_ctx->undo->proTos1pri
     */
    rowreq_ctx->data.proTos1pri = rowreq_ctx->undo->proTos1pri;

    
    return MFD_SUCCESS;
} /* proTos1pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos2pri
 * proTos2pri is subid 26 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.26
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos2pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos2pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos2pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos2pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos2pri value.
     */

    return MFD_SUCCESS; /* proTos2pri value not illegal */
} /* proTos2pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos2pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos2pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos2pri undo.
     */
    /*
     * copy proTos2pri data
     * set rowreq_ctx->undo->proTos2pri from rowreq_ctx->data.proTos2pri
     */
    rowreq_ctx->undo->proTos2pri = rowreq_ctx->data.proTos2pri;


    return MFD_SUCCESS;
} /* proTos2pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos2pri_val
 *        A long containing the new value.
 */
int
proTos2pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos2pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos2pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos2pri value.
     * set proTos2pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos2pri = proTos2pri_val;

    return MFD_SUCCESS;
} /* proTos2pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos2pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos2pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos2pri undo.
     */
    /*
     * copy proTos2pri data
     * set rowreq_ctx->data.proTos2pri from rowreq_ctx->undo->proTos2pri
     */
    rowreq_ctx->data.proTos2pri = rowreq_ctx->undo->proTos2pri;

    
    return MFD_SUCCESS;
} /* proTos2pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos3pri
 * proTos3pri is subid 27 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.27
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos3pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos3pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos3pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos3pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos3pri value.
     */

    return MFD_SUCCESS; /* proTos3pri value not illegal */
} /* proTos3pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos3pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos3pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos3pri undo.
     */
    /*
     * copy proTos3pri data
     * set rowreq_ctx->undo->proTos3pri from rowreq_ctx->data.proTos3pri
     */
    rowreq_ctx->undo->proTos3pri = rowreq_ctx->data.proTos3pri;


    return MFD_SUCCESS;
} /* proTos3pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos3pri_val
 *        A long containing the new value.
 */
int
proTos3pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos3pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos3pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos3pri value.
     * set proTos3pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos3pri = proTos3pri_val;

    return MFD_SUCCESS;
} /* proTos3pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos3pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos3pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos3pri undo.
     */
    /*
     * copy proTos3pri data
     * set rowreq_ctx->data.proTos3pri from rowreq_ctx->undo->proTos3pri
     */
    rowreq_ctx->data.proTos3pri = rowreq_ctx->undo->proTos3pri;

    
    return MFD_SUCCESS;
} /* proTos3pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos4pri
 * proTos4pri is subid 28 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.28
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos4pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos4pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos4pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos4pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos4pri value.
     */

    return MFD_SUCCESS; /* proTos4pri value not illegal */
} /* proTos4pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos4pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos4pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos4pri undo.
     */
    /*
     * copy proTos4pri data
     * set rowreq_ctx->undo->proTos4pri from rowreq_ctx->data.proTos4pri
     */
    rowreq_ctx->undo->proTos4pri = rowreq_ctx->data.proTos4pri;


    return MFD_SUCCESS;
} /* proTos4pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos4pri_val
 *        A long containing the new value.
 */
int
proTos4pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos4pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos4pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos4pri value.
     * set proTos4pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos4pri = proTos4pri_val;

    return MFD_SUCCESS;
} /* proTos4pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos4pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos4pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos4pri undo.
     */
    /*
     * copy proTos4pri data
     * set rowreq_ctx->data.proTos4pri from rowreq_ctx->undo->proTos4pri
     */
    rowreq_ctx->data.proTos4pri = rowreq_ctx->undo->proTos4pri;

    
    return MFD_SUCCESS;
} /* proTos4pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos5pri
 * proTos5pri is subid 29 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.29
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos5pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos5pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos5pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos5pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos5pri value.
     */

    return MFD_SUCCESS; /* proTos5pri value not illegal */
} /* proTos5pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos5pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos5pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos5pri undo.
     */
    /*
     * copy proTos5pri data
     * set rowreq_ctx->undo->proTos5pri from rowreq_ctx->data.proTos5pri
     */
    rowreq_ctx->undo->proTos5pri = rowreq_ctx->data.proTos5pri;


    return MFD_SUCCESS;
} /* proTos5pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos5pri_val
 *        A long containing the new value.
 */
int
proTos5pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos5pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos5pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos5pri value.
     * set proTos5pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos5pri = proTos5pri_val;

    return MFD_SUCCESS;
} /* proTos5pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos5pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos5pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos5pri undo.
     */
    /*
     * copy proTos5pri data
     * set rowreq_ctx->data.proTos5pri from rowreq_ctx->undo->proTos5pri
     */
    rowreq_ctx->data.proTos5pri = rowreq_ctx->undo->proTos5pri;

    
    return MFD_SUCCESS;
} /* proTos5pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos6pri
 * proTos6pri is subid 30 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.30
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos6pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos6pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos6pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos6pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos6pri value.
     */

    return MFD_SUCCESS; /* proTos6pri value not illegal */
} /* proTos6pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos6pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos6pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos6pri undo.
     */
    /*
     * copy proTos6pri data
     * set rowreq_ctx->undo->proTos6pri from rowreq_ctx->data.proTos6pri
     */
    rowreq_ctx->undo->proTos6pri = rowreq_ctx->data.proTos6pri;


    return MFD_SUCCESS;
} /* proTos6pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos6pri_val
 *        A long containing the new value.
 */
int
proTos6pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos6pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos6pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos6pri value.
     * set proTos6pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos6pri = proTos6pri_val;

    return MFD_SUCCESS;
} /* proTos6pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos6pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos6pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos6pri undo.
     */
    /*
     * copy proTos6pri data
     * set rowreq_ctx->data.proTos6pri from rowreq_ctx->undo->proTos6pri
     */
    rowreq_ctx->data.proTos6pri = rowreq_ctx->undo->proTos6pri;

    
    return MFD_SUCCESS;
} /* proTos6pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTos7pri
 * proTos7pri is subid 31 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.31
 * Description:
TOS priority mappings.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * Its syntax is PriQueueValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTos7pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  cap0(0), cap1(1), cap2(2), cap3(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTos7pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos7pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTos7pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTos7pri value.
     */

    return MFD_SUCCESS; /* proTos7pri value not illegal */
} /* proTos7pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTos7pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTos7pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTos7pri undo.
     */
    /*
     * copy proTos7pri data
     * set rowreq_ctx->undo->proTos7pri from rowreq_ctx->data.proTos7pri
     */
    rowreq_ctx->undo->proTos7pri = rowreq_ctx->data.proTos7pri;


    return MFD_SUCCESS;
} /* proTos7pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTos7pri_val
 *        A long containing the new value.
 */
int
proTos7pri_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTos7pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTos7pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTos7pri value.
     * set proTos7pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTos7pri = proTos7pri_val;

    return MFD_SUCCESS;
} /* proTos7pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTos7pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTos7pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTos7pri undo.
     */
    /*
     * copy proTos7pri data
     * set rowreq_ctx->data.proTos7pri from rowreq_ctx->undo->proTos7pri
     */
    rowreq_ctx->data.proTos7pri = rowreq_ctx->undo->proTos7pri;

    
    return MFD_SUCCESS;
} /* proTos7pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proSfbSts
 * proSfbSts is subid 32 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.32
 * Description:
Broadcast storm filter status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proSfbSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proSfbSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfbSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proSfbSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proSfbSts value.
     */

    return MFD_SUCCESS; /* proSfbSts value not illegal */
} /* proSfbSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proSfbSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proSfbSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proSfbSts undo.
     */
    /*
     * copy proSfbSts data
     * set rowreq_ctx->undo->proSfbSts from rowreq_ctx->data.proSfbSts
     */
    rowreq_ctx->undo->proSfbSts = rowreq_ctx->data.proSfbSts;


    return MFD_SUCCESS;
} /* proSfbSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proSfbSts_val
 *        A long containing the new value.
 */
int
proSfbSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfbSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proSfbSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proSfbSts value.
     * set proSfbSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proSfbSts = proSfbSts_val;

    return MFD_SUCCESS;
} /* proSfbSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proSfbSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proSfbSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proSfbSts undo.
     */
    /*
     * copy proSfbSts data
     * set rowreq_ctx->data.proSfbSts from rowreq_ctx->undo->proSfbSts
     */
    rowreq_ctx->data.proSfbSts = rowreq_ctx->undo->proSfbSts;

    
    return MFD_SUCCESS;
} /* proSfbSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proSfuSts
 * proSfuSts is subid 33 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.33
 * Description:
Unknown unicast storm filter status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proSfuSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proSfuSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfuSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proSfuSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proSfuSts value.
     */

    return MFD_SUCCESS; /* proSfuSts value not illegal */
} /* proSfuSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proSfuSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proSfuSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proSfuSts undo.
     */
    /*
     * copy proSfuSts data
     * set rowreq_ctx->undo->proSfuSts from rowreq_ctx->data.proSfuSts
     */
    rowreq_ctx->undo->proSfuSts = rowreq_ctx->data.proSfuSts;


    return MFD_SUCCESS;
} /* proSfuSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proSfuSts_val
 *        A long containing the new value.
 */
int
proSfuSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfuSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proSfuSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proSfuSts value.
     * set proSfuSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proSfuSts = proSfuSts_val;

    return MFD_SUCCESS;
} /* proSfuSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proSfuSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proSfuSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proSfuSts undo.
     */
    /*
     * copy proSfuSts data
     * set rowreq_ctx->data.proSfuSts from rowreq_ctx->undo->proSfuSts
     */
    rowreq_ctx->data.proSfuSts = rowreq_ctx->undo->proSfuSts;

    
    return MFD_SUCCESS;
} /* proSfuSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proSfmSts
 * proSfmSts is subid 34 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.34
 * Description:
Unknown multicast storm filter status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proSfmSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proSfmSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfmSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proSfmSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proSfmSts value.
     */

    return MFD_SUCCESS; /* proSfmSts value not illegal */
} /* proSfmSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proSfmSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proSfmSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proSfmSts undo.
     */
    /*
     * copy proSfmSts data
     * set rowreq_ctx->undo->proSfmSts from rowreq_ctx->data.proSfmSts
     */
    rowreq_ctx->undo->proSfmSts = rowreq_ctx->data.proSfmSts;


    return MFD_SUCCESS;
} /* proSfmSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proSfmSts_val
 *        A long containing the new value.
 */
int
proSfmSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfmSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proSfmSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proSfmSts value.
     * set proSfmSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proSfmSts = proSfmSts_val;

    return MFD_SUCCESS;
} /* proSfmSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proSfmSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proSfmSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proSfmSts undo.
     */
    /*
     * copy proSfmSts data
     * set rowreq_ctx->data.proSfmSts from rowreq_ctx->undo->proSfmSts
     */
    rowreq_ctx->data.proSfmSts = rowreq_ctx->undo->proSfmSts;

    
    return MFD_SUCCESS;
} /* proSfmSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proSfRate
 * proSfRate is subid 35 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.35
 * Description:
Storm control rate level from 0 to 11.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 10/16. Values:  sfl_disabled(0), sfl_1kpps(1), sfl_2kpps(2), sfl_4kpps(3), sfl_8kpps(4), sfl_16kpps(5), sfl_32kpps(6), sfl_64kpps(7), sfl_128kpps(8), sfl_256kpps(9), sfl_512kpps(10), sfl_1024kpps(11)
 *
 * Its syntax is StromFilterValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proSfRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  sfl_disabled(0), sfl_1kpps(1), sfl_2kpps(2), sfl_4kpps(3), sfl_8kpps(4), sfl_16kpps(5), sfl_32kpps(6), sfl_64kpps(7), sfl_128kpps(8), sfl_256kpps(9), sfl_512kpps(10), sfl_1024kpps(11)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proSfRate_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfRate_val)
{
    DEBUGMSGTL(("verbose:profileTable:proSfRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proSfRate value.
     */

    return MFD_SUCCESS; /* proSfRate value not illegal */
} /* proSfRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proSfRate_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proSfRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proSfRate undo.
     */
    /*
     * copy proSfRate data
     * set rowreq_ctx->undo->proSfRate from rowreq_ctx->data.proSfRate
     */
    rowreq_ctx->undo->proSfRate = rowreq_ctx->data.proSfRate;


    return MFD_SUCCESS;
} /* proSfRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proSfRate_val
 *        A long containing the new value.
 */
int
proSfRate_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proSfRate_val )
{

    DEBUGMSGTL(("verbose:profileTable:proSfRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proSfRate value.
     * set proSfRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.proSfRate = proSfRate_val;

    return MFD_SUCCESS;
} /* proSfRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proSfRate_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proSfRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proSfRate undo.
     */
    /*
     * copy proSfRate data
     * set rowreq_ctx->data.proSfRate from rowreq_ctx->undo->proSfRate
     */
    rowreq_ctx->data.proSfRate = rowreq_ctx->undo->proSfRate;

    
    return MFD_SUCCESS;
} /* proSfRate_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proVlanStatus
 * proVlanStatus is subid 36 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.36
 * Description:
CNU vlan status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proVlanStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proVlanStatus_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proVlanStatus_val)
{
    DEBUGMSGTL(("verbose:profileTable:proVlanStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proVlanStatus value.
     */

    return MFD_SUCCESS; /* proVlanStatus value not illegal */
} /* proVlanStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proVlanStatus_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proVlanStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proVlanStatus undo.
     */
    /*
     * copy proVlanStatus data
     * set rowreq_ctx->undo->proVlanStatus from rowreq_ctx->data.proVlanStatus
     */
    rowreq_ctx->undo->proVlanStatus = rowreq_ctx->data.proVlanStatus;


    return MFD_SUCCESS;
} /* proVlanStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proVlanStatus_val
 *        A long containing the new value.
 */
int
proVlanStatus_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proVlanStatus_val )
{

    DEBUGMSGTL(("verbose:profileTable:proVlanStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proVlanStatus value.
     * set proVlanStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.proVlanStatus = proVlanStatus_val;

    return MFD_SUCCESS;
} /* proVlanStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proVlanStatus_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proVlanStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proVlanStatus undo.
     */
    /*
     * copy proVlanStatus data
     * set rowreq_ctx->data.proVlanStatus from rowreq_ctx->undo->proVlanStatus
     */
    rowreq_ctx->data.proVlanStatus = rowreq_ctx->undo->proVlanStatus;

    
    return MFD_SUCCESS;
} /* proVlanStatus_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth1vid
 * proEth1vid is subid 37 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.37
 * Description:
CNU eth1 vlan id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4094;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth1vid_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 4094
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth1vid_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth1vid_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1vid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth1vid value.
     */

    return MFD_SUCCESS; /* proEth1vid value not illegal */
} /* proEth1vid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth1vid_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1vid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth1vid undo.
     */
    /*
     * copy proEth1vid data
     * set rowreq_ctx->undo->proEth1vid from rowreq_ctx->data.proEth1vid
     */
    rowreq_ctx->undo->proEth1vid = rowreq_ctx->data.proEth1vid;


    return MFD_SUCCESS;
} /* proEth1vid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth1vid_val
 *        A long containing the new value.
 */
int
proEth1vid_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth1vid_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth1vid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth1vid value.
     * set proEth1vid value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth1vid = proEth1vid_val;

    return MFD_SUCCESS;
} /* proEth1vid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth1vid_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth1vid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth1vid undo.
     */
    /*
     * copy proEth1vid data
     * set rowreq_ctx->data.proEth1vid from rowreq_ctx->undo->proEth1vid
     */
    rowreq_ctx->data.proEth1vid = rowreq_ctx->undo->proEth1vid;

    
    return MFD_SUCCESS;
} /* proEth1vid_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth2vid
 * proEth2vid is subid 38 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.38
 * Description:
CNU eth2 vlan id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4094;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth2vid_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 4094
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth2vid_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth2vid_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2vid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth2vid value.
     */

    return MFD_SUCCESS; /* proEth2vid value not illegal */
} /* proEth2vid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth2vid_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2vid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth2vid undo.
     */
    /*
     * copy proEth2vid data
     * set rowreq_ctx->undo->proEth2vid from rowreq_ctx->data.proEth2vid
     */
    rowreq_ctx->undo->proEth2vid = rowreq_ctx->data.proEth2vid;


    return MFD_SUCCESS;
} /* proEth2vid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth2vid_val
 *        A long containing the new value.
 */
int
proEth2vid_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth2vid_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth2vid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth2vid value.
     * set proEth2vid value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth2vid = proEth2vid_val;

    return MFD_SUCCESS;
} /* proEth2vid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth2vid_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth2vid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth2vid undo.
     */
    /*
     * copy proEth2vid data
     * set rowreq_ctx->data.proEth2vid from rowreq_ctx->undo->proEth2vid
     */
    rowreq_ctx->data.proEth2vid = rowreq_ctx->undo->proEth2vid;

    
    return MFD_SUCCESS;
} /* proEth2vid_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth3vid
 * proEth3vid is subid 39 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.39
 * Description:
CNU eth3 vlan id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4094;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth3vid_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 4094
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth3vid_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth3vid_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3vid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth3vid value.
     */

    return MFD_SUCCESS; /* proEth3vid value not illegal */
} /* proEth3vid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth3vid_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3vid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth3vid undo.
     */
    /*
     * copy proEth3vid data
     * set rowreq_ctx->undo->proEth3vid from rowreq_ctx->data.proEth3vid
     */
    rowreq_ctx->undo->proEth3vid = rowreq_ctx->data.proEth3vid;


    return MFD_SUCCESS;
} /* proEth3vid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth3vid_val
 *        A long containing the new value.
 */
int
proEth3vid_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth3vid_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth3vid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth3vid value.
     * set proEth3vid value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth3vid = proEth3vid_val;

    return MFD_SUCCESS;
} /* proEth3vid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth3vid_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth3vid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth3vid undo.
     */
    /*
     * copy proEth3vid data
     * set rowreq_ctx->data.proEth3vid from rowreq_ctx->undo->proEth3vid
     */
    rowreq_ctx->data.proEth3vid = rowreq_ctx->undo->proEth3vid;

    
    return MFD_SUCCESS;
} /* proEth3vid_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth4vid
 * proEth4vid is subid 40 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.40
 * Description:
CNU eth4 vlan id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4094;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth4vid_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 4094
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth4vid_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth4vid_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4vid_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth4vid value.
     */

    return MFD_SUCCESS; /* proEth4vid value not illegal */
} /* proEth4vid_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth4vid_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4vid_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth4vid undo.
     */
    /*
     * copy proEth4vid data
     * set rowreq_ctx->undo->proEth4vid from rowreq_ctx->data.proEth4vid
     */
    rowreq_ctx->undo->proEth4vid = rowreq_ctx->data.proEth4vid;


    return MFD_SUCCESS;
} /* proEth4vid_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth4vid_val
 *        A long containing the new value.
 */
int
proEth4vid_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth4vid_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth4vid_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth4vid value.
     * set proEth4vid value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth4vid = proEth4vid_val;

    return MFD_SUCCESS;
} /* proEth4vid_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth4vid_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth4vid_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth4vid undo.
     */
    /*
     * copy proEth4vid data
     * set rowreq_ctx->data.proEth4vid from rowreq_ctx->undo->proEth4vid
     */
    rowreq_ctx->data.proEth4vid = rowreq_ctx->undo->proEth4vid;

    
    return MFD_SUCCESS;
} /* proEth4vid_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proPortPriSts
 * proPortPriSts is subid 41 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.41
 * Description:
CNU port priority config status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proPortPriSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proPortPriSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proPortPriSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proPortPriSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proPortPriSts value.
     */

    return MFD_SUCCESS; /* proPortPriSts value not illegal */
} /* proPortPriSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proPortPriSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proPortPriSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proPortPriSts undo.
     */
    /*
     * copy proPortPriSts data
     * set rowreq_ctx->undo->proPortPriSts from rowreq_ctx->data.proPortPriSts
     */
    rowreq_ctx->undo->proPortPriSts = rowreq_ctx->data.proPortPriSts;


    return MFD_SUCCESS;
} /* proPortPriSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proPortPriSts_val
 *        A long containing the new value.
 */
int
proPortPriSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proPortPriSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proPortPriSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proPortPriSts value.
     * set proPortPriSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proPortPriSts = proPortPriSts_val;

    return MFD_SUCCESS;
} /* proPortPriSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proPortPriSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proPortPriSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proPortPriSts undo.
     */
    /*
     * copy proPortPriSts data
     * set rowreq_ctx->data.proPortPriSts from rowreq_ctx->undo->proPortPriSts
     */
    rowreq_ctx->data.proPortPriSts = rowreq_ctx->undo->proPortPriSts;

    
    return MFD_SUCCESS;
} /* proPortPriSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth1pri
 * proEth1pri is subid 42 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.42
 * Description:
cnu port pri value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth1pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth1pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth1pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth1pri value.
     */

    return MFD_SUCCESS; /* proEth1pri value not illegal */
} /* proEth1pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth1pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth1pri undo.
     */
    /*
     * copy proEth1pri data
     * set rowreq_ctx->undo->proEth1pri from rowreq_ctx->data.proEth1pri
     */
    rowreq_ctx->undo->proEth1pri = rowreq_ctx->data.proEth1pri;


    return MFD_SUCCESS;
} /* proEth1pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth1pri_val
 *        A long containing the new value.
 */
int
proEth1pri_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth1pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth1pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth1pri value.
     * set proEth1pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth1pri = proEth1pri_val;

    return MFD_SUCCESS;
} /* proEth1pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth1pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth1pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth1pri undo.
     */
    /*
     * copy proEth1pri data
     * set rowreq_ctx->data.proEth1pri from rowreq_ctx->undo->proEth1pri
     */
    rowreq_ctx->data.proEth1pri = rowreq_ctx->undo->proEth1pri;

    
    return MFD_SUCCESS;
} /* proEth1pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth2pri
 * proEth2pri is subid 43 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.43
 * Description:
cnu port pri value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth2pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth2pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth2pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth2pri value.
     */

    return MFD_SUCCESS; /* proEth2pri value not illegal */
} /* proEth2pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth2pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth2pri undo.
     */
    /*
     * copy proEth2pri data
     * set rowreq_ctx->undo->proEth2pri from rowreq_ctx->data.proEth2pri
     */
    rowreq_ctx->undo->proEth2pri = rowreq_ctx->data.proEth2pri;


    return MFD_SUCCESS;
} /* proEth2pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth2pri_val
 *        A long containing the new value.
 */
int
proEth2pri_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth2pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth2pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth2pri value.
     * set proEth2pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth2pri = proEth2pri_val;

    return MFD_SUCCESS;
} /* proEth2pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth2pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth2pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth2pri undo.
     */
    /*
     * copy proEth2pri data
     * set rowreq_ctx->data.proEth2pri from rowreq_ctx->undo->proEth2pri
     */
    rowreq_ctx->data.proEth2pri = rowreq_ctx->undo->proEth2pri;

    
    return MFD_SUCCESS;
} /* proEth2pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth3pri
 * proEth3pri is subid 44 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.44
 * Description:
cnu port pri value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth3pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth3pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth3pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth3pri value.
     */

    return MFD_SUCCESS; /* proEth3pri value not illegal */
} /* proEth3pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth3pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth3pri undo.
     */
    /*
     * copy proEth3pri data
     * set rowreq_ctx->undo->proEth3pri from rowreq_ctx->data.proEth3pri
     */
    rowreq_ctx->undo->proEth3pri = rowreq_ctx->data.proEth3pri;


    return MFD_SUCCESS;
} /* proEth3pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth3pri_val
 *        A long containing the new value.
 */
int
proEth3pri_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth3pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth3pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth3pri value.
     * set proEth3pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth3pri = proEth3pri_val;

    return MFD_SUCCESS;
} /* proEth3pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth3pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth3pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth3pri undo.
     */
    /*
     * copy proEth3pri data
     * set rowreq_ctx->data.proEth3pri from rowreq_ctx->undo->proEth3pri
     */
    rowreq_ctx->data.proEth3pri = rowreq_ctx->undo->proEth3pri;

    
    return MFD_SUCCESS;
} /* proEth3pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth4pri
 * proEth4pri is subid 45 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.45
 * Description:
cnu port pri value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth4pri_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth4pri_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth4pri_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4pri_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth4pri value.
     */

    return MFD_SUCCESS; /* proEth4pri value not illegal */
} /* proEth4pri_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth4pri_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4pri_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth4pri undo.
     */
    /*
     * copy proEth4pri data
     * set rowreq_ctx->undo->proEth4pri from rowreq_ctx->data.proEth4pri
     */
    rowreq_ctx->undo->proEth4pri = rowreq_ctx->data.proEth4pri;


    return MFD_SUCCESS;
} /* proEth4pri_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth4pri_val
 *        A long containing the new value.
 */
int
proEth4pri_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth4pri_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth4pri_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth4pri value.
     * set proEth4pri value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth4pri = proEth4pri_val;

    return MFD_SUCCESS;
} /* proEth4pri_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth4pri_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth4pri_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth4pri undo.
     */
    /*
     * copy proEth4pri data
     * set rowreq_ctx->data.proEth4pri from rowreq_ctx->undo->proEth4pri
     */
    rowreq_ctx->data.proEth4pri = rowreq_ctx->undo->proEth4pri;

    
    return MFD_SUCCESS;
} /* proEth4pri_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proRxLimitSts
 * proRxLimitSts is subid 46 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.46
 * Description:
CNU port RX rate limiting status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proRxLimitSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proRxLimitSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proRxLimitSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proRxLimitSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proRxLimitSts value.
     */

    return MFD_SUCCESS; /* proRxLimitSts value not illegal */
} /* proRxLimitSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proRxLimitSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proRxLimitSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proRxLimitSts undo.
     */
    /*
     * copy proRxLimitSts data
     * set rowreq_ctx->undo->proRxLimitSts from rowreq_ctx->data.proRxLimitSts
     */
    rowreq_ctx->undo->proRxLimitSts = rowreq_ctx->data.proRxLimitSts;


    return MFD_SUCCESS;
} /* proRxLimitSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proRxLimitSts_val
 *        A long containing the new value.
 */
int
proRxLimitSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proRxLimitSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proRxLimitSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proRxLimitSts value.
     * set proRxLimitSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proRxLimitSts = proRxLimitSts_val;

    return MFD_SUCCESS;
} /* proRxLimitSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proRxLimitSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proRxLimitSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proRxLimitSts undo.
     */
    /*
     * copy proRxLimitSts data
     * set rowreq_ctx->data.proRxLimitSts from rowreq_ctx->undo->proRxLimitSts
     */
    rowreq_ctx->data.proRxLimitSts = rowreq_ctx->undo->proRxLimitSts;

    
    return MFD_SUCCESS;
} /* proRxLimitSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCpuPortRxRate
 * proCpuPortRxRate is subid 47 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.47
 * Description:
CNU cpu port rx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCpuPortRxRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCpuPortRxRate_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proCpuPortRxRate_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCpuPortRxRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCpuPortRxRate value.
     */

    return MFD_SUCCESS; /* proCpuPortRxRate value not illegal */
} /* proCpuPortRxRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCpuPortRxRate_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCpuPortRxRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCpuPortRxRate undo.
     */
    /*
     * copy proCpuPortRxRate data
     * set rowreq_ctx->undo->proCpuPortRxRate from rowreq_ctx->data.proCpuPortRxRate
     */
    rowreq_ctx->undo->proCpuPortRxRate = rowreq_ctx->data.proCpuPortRxRate;


    return MFD_SUCCESS;
} /* proCpuPortRxRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCpuPortRxRate_val
 *        A long containing the new value.
 */
int
proCpuPortRxRate_set( profileTable_rowreq_ctx *rowreq_ctx, long proCpuPortRxRate_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCpuPortRxRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCpuPortRxRate value.
     * set proCpuPortRxRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCpuPortRxRate = proCpuPortRxRate_val;

    return MFD_SUCCESS;
} /* proCpuPortRxRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCpuPortRxRate_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCpuPortRxRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCpuPortRxRate undo.
     */
    /*
     * copy proCpuPortRxRate data
     * set rowreq_ctx->data.proCpuPortRxRate from rowreq_ctx->undo->proCpuPortRxRate
     */
    rowreq_ctx->data.proCpuPortRxRate = rowreq_ctx->undo->proCpuPortRxRate;

    
    return MFD_SUCCESS;
} /* proCpuPortRxRate_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth1rx
 * proEth1rx is subid 48 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.48
 * Description:
eth1 port rx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth1rx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth1rx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth1rx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1rx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth1rx value.
     */

    return MFD_SUCCESS; /* proEth1rx value not illegal */
} /* proEth1rx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth1rx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1rx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth1rx undo.
     */
    /*
     * copy proEth1rx data
     * set rowreq_ctx->undo->proEth1rx from rowreq_ctx->data.proEth1rx
     */
    rowreq_ctx->undo->proEth1rx = rowreq_ctx->data.proEth1rx;


    return MFD_SUCCESS;
} /* proEth1rx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth1rx_val
 *        A long containing the new value.
 */
int
proEth1rx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth1rx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth1rx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth1rx value.
     * set proEth1rx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth1rx = proEth1rx_val;

    return MFD_SUCCESS;
} /* proEth1rx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth1rx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth1rx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth1rx undo.
     */
    /*
     * copy proEth1rx data
     * set rowreq_ctx->data.proEth1rx from rowreq_ctx->undo->proEth1rx
     */
    rowreq_ctx->data.proEth1rx = rowreq_ctx->undo->proEth1rx;

    
    return MFD_SUCCESS;
} /* proEth1rx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth2rx
 * proEth2rx is subid 49 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.49
 * Description:
eth2 port rx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth2rx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth2rx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth2rx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2rx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth2rx value.
     */

    return MFD_SUCCESS; /* proEth2rx value not illegal */
} /* proEth2rx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth2rx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2rx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth2rx undo.
     */
    /*
     * copy proEth2rx data
     * set rowreq_ctx->undo->proEth2rx from rowreq_ctx->data.proEth2rx
     */
    rowreq_ctx->undo->proEth2rx = rowreq_ctx->data.proEth2rx;


    return MFD_SUCCESS;
} /* proEth2rx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth2rx_val
 *        A long containing the new value.
 */
int
proEth2rx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth2rx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth2rx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth2rx value.
     * set proEth2rx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth2rx = proEth2rx_val;

    return MFD_SUCCESS;
} /* proEth2rx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth2rx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth2rx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth2rx undo.
     */
    /*
     * copy proEth2rx data
     * set rowreq_ctx->data.proEth2rx from rowreq_ctx->undo->proEth2rx
     */
    rowreq_ctx->data.proEth2rx = rowreq_ctx->undo->proEth2rx;

    
    return MFD_SUCCESS;
} /* proEth2rx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth3rx
 * proEth3rx is subid 50 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.50
 * Description:
eth3 port rx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth3rx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth3rx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth3rx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3rx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth3rx value.
     */

    return MFD_SUCCESS; /* proEth3rx value not illegal */
} /* proEth3rx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth3rx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3rx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth3rx undo.
     */
    /*
     * copy proEth3rx data
     * set rowreq_ctx->undo->proEth3rx from rowreq_ctx->data.proEth3rx
     */
    rowreq_ctx->undo->proEth3rx = rowreq_ctx->data.proEth3rx;


    return MFD_SUCCESS;
} /* proEth3rx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth3rx_val
 *        A long containing the new value.
 */
int
proEth3rx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth3rx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth3rx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth3rx value.
     * set proEth3rx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth3rx = proEth3rx_val;

    return MFD_SUCCESS;
} /* proEth3rx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth3rx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth3rx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth3rx undo.
     */
    /*
     * copy proEth3rx data
     * set rowreq_ctx->data.proEth3rx from rowreq_ctx->undo->proEth3rx
     */
    rowreq_ctx->data.proEth3rx = rowreq_ctx->undo->proEth3rx;

    
    return MFD_SUCCESS;
} /* proEth3rx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth4rx
 * proEth4rx is subid 51 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.51
 * Description:
eth4 port rx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth4rx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth4rx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth4rx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4rx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth4rx value.
     */

    return MFD_SUCCESS; /* proEth4rx value not illegal */
} /* proEth4rx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth4rx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4rx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth4rx undo.
     */
    /*
     * copy proEth4rx data
     * set rowreq_ctx->undo->proEth4rx from rowreq_ctx->data.proEth4rx
     */
    rowreq_ctx->undo->proEth4rx = rowreq_ctx->data.proEth4rx;


    return MFD_SUCCESS;
} /* proEth4rx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth4rx_val
 *        A long containing the new value.
 */
int
proEth4rx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth4rx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth4rx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth4rx value.
     * set proEth4rx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth4rx = proEth4rx_val;

    return MFD_SUCCESS;
} /* proEth4rx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth4rx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth4rx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth4rx undo.
     */
    /*
     * copy proEth4rx data
     * set rowreq_ctx->data.proEth4rx from rowreq_ctx->undo->proEth4rx
     */
    rowreq_ctx->data.proEth4rx = rowreq_ctx->undo->proEth4rx;

    
    return MFD_SUCCESS;
} /* proEth4rx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proTxLimitSts
 * proTxLimitSts is subid 52 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.52
 * Description:
CNU port TX rate limiting status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proTxLimitSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proTxLimitSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proTxLimitSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proTxLimitSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proTxLimitSts value.
     */

    return MFD_SUCCESS; /* proTxLimitSts value not illegal */
} /* proTxLimitSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proTxLimitSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proTxLimitSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proTxLimitSts undo.
     */
    /*
     * copy proTxLimitSts data
     * set rowreq_ctx->undo->proTxLimitSts from rowreq_ctx->data.proTxLimitSts
     */
    rowreq_ctx->undo->proTxLimitSts = rowreq_ctx->data.proTxLimitSts;


    return MFD_SUCCESS;
} /* proTxLimitSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proTxLimitSts_val
 *        A long containing the new value.
 */
int
proTxLimitSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proTxLimitSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proTxLimitSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proTxLimitSts value.
     * set proTxLimitSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proTxLimitSts = proTxLimitSts_val;

    return MFD_SUCCESS;
} /* proTxLimitSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proTxLimitSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proTxLimitSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proTxLimitSts undo.
     */
    /*
     * copy proTxLimitSts data
     * set rowreq_ctx->data.proTxLimitSts from rowreq_ctx->undo->proTxLimitSts
     */
    rowreq_ctx->data.proTxLimitSts = rowreq_ctx->undo->proTxLimitSts;

    
    return MFD_SUCCESS;
} /* proTxLimitSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCpuPortTxRate
 * proCpuPortTxRate is subid 53 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.53
 * Description:
CNU cpu port tx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCpuPortTxRate_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCpuPortTxRate_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proCpuPortTxRate_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCpuPortTxRate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCpuPortTxRate value.
     */

    return MFD_SUCCESS; /* proCpuPortTxRate value not illegal */
} /* proCpuPortTxRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCpuPortTxRate_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCpuPortTxRate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCpuPortTxRate undo.
     */
    /*
     * copy proCpuPortTxRate data
     * set rowreq_ctx->undo->proCpuPortTxRate from rowreq_ctx->data.proCpuPortTxRate
     */
    rowreq_ctx->undo->proCpuPortTxRate = rowreq_ctx->data.proCpuPortTxRate;


    return MFD_SUCCESS;
} /* proCpuPortTxRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCpuPortTxRate_val
 *        A long containing the new value.
 */
int
proCpuPortTxRate_set( profileTable_rowreq_ctx *rowreq_ctx, long proCpuPortTxRate_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCpuPortTxRate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCpuPortTxRate value.
     * set proCpuPortTxRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCpuPortTxRate = proCpuPortTxRate_val;

    return MFD_SUCCESS;
} /* proCpuPortTxRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCpuPortTxRate_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCpuPortTxRate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCpuPortTxRate undo.
     */
    /*
     * copy proCpuPortTxRate data
     * set rowreq_ctx->data.proCpuPortTxRate from rowreq_ctx->undo->proCpuPortTxRate
     */
    rowreq_ctx->data.proCpuPortTxRate = rowreq_ctx->undo->proCpuPortTxRate;

    
    return MFD_SUCCESS;
} /* proCpuPortTxRate_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth1tx
 * proEth1tx is subid 54 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.54
 * Description:
eth1 port tx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth1tx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth1tx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth1tx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1tx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth1tx value.
     */

    return MFD_SUCCESS; /* proEth1tx value not illegal */
} /* proEth1tx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth1tx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1tx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth1tx undo.
     */
    /*
     * copy proEth1tx data
     * set rowreq_ctx->undo->proEth1tx from rowreq_ctx->data.proEth1tx
     */
    rowreq_ctx->undo->proEth1tx = rowreq_ctx->data.proEth1tx;


    return MFD_SUCCESS;
} /* proEth1tx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth1tx_val
 *        A long containing the new value.
 */
int
proEth1tx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth1tx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth1tx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth1tx value.
     * set proEth1tx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth1tx = proEth1tx_val;

    return MFD_SUCCESS;
} /* proEth1tx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth1tx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth1tx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth1tx undo.
     */
    /*
     * copy proEth1tx data
     * set rowreq_ctx->data.proEth1tx from rowreq_ctx->undo->proEth1tx
     */
    rowreq_ctx->data.proEth1tx = rowreq_ctx->undo->proEth1tx;

    
    return MFD_SUCCESS;
} /* proEth1tx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth2tx
 * proEth2tx is subid 55 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.55
 * Description:
eth2 port tx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth2tx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth2tx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth2tx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2tx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth2tx value.
     */

    return MFD_SUCCESS; /* proEth2tx value not illegal */
} /* proEth2tx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth2tx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2tx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth2tx undo.
     */
    /*
     * copy proEth2tx data
     * set rowreq_ctx->undo->proEth2tx from rowreq_ctx->data.proEth2tx
     */
    rowreq_ctx->undo->proEth2tx = rowreq_ctx->data.proEth2tx;


    return MFD_SUCCESS;
} /* proEth2tx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth2tx_val
 *        A long containing the new value.
 */
int
proEth2tx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth2tx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth2tx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth2tx value.
     * set proEth2tx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth2tx = proEth2tx_val;

    return MFD_SUCCESS;
} /* proEth2tx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth2tx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth2tx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth2tx undo.
     */
    /*
     * copy proEth2tx data
     * set rowreq_ctx->data.proEth2tx from rowreq_ctx->undo->proEth2tx
     */
    rowreq_ctx->data.proEth2tx = rowreq_ctx->undo->proEth2tx;

    
    return MFD_SUCCESS;
} /* proEth2tx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth3tx
 * proEth3tx is subid 56 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.56
 * Description:
eth3 port tx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth3tx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth3tx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth3tx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3tx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth3tx value.
     */

    return MFD_SUCCESS; /* proEth3tx value not illegal */
} /* proEth3tx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth3tx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3tx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth3tx undo.
     */
    /*
     * copy proEth3tx data
     * set rowreq_ctx->undo->proEth3tx from rowreq_ctx->data.proEth3tx
     */
    rowreq_ctx->undo->proEth3tx = rowreq_ctx->data.proEth3tx;


    return MFD_SUCCESS;
} /* proEth3tx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth3tx_val
 *        A long containing the new value.
 */
int
proEth3tx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth3tx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth3tx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth3tx value.
     * set proEth3tx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth3tx = proEth3tx_val;

    return MFD_SUCCESS;
} /* proEth3tx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth3tx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth3tx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth3tx undo.
     */
    /*
     * copy proEth3tx data
     * set rowreq_ctx->data.proEth3tx from rowreq_ctx->undo->proEth3tx
     */
    rowreq_ctx->data.proEth3tx = rowreq_ctx->undo->proEth3tx;

    
    return MFD_SUCCESS;
} /* proEth3tx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth4tx
 * proEth4tx is subid 57 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.57
 * Description:
eth4 port tx rate limiting.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth4tx_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth4tx_check_value( profileTable_rowreq_ctx *rowreq_ctx, long proEth4tx_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4tx_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth4tx value.
     */

    return MFD_SUCCESS; /* proEth4tx value not illegal */
} /* proEth4tx_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth4tx_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4tx_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth4tx undo.
     */
    /*
     * copy proEth4tx data
     * set rowreq_ctx->undo->proEth4tx from rowreq_ctx->data.proEth4tx
     */
    rowreq_ctx->undo->proEth4tx = rowreq_ctx->data.proEth4tx;


    return MFD_SUCCESS;
} /* proEth4tx_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth4tx_val
 *        A long containing the new value.
 */
int
proEth4tx_set( profileTable_rowreq_ctx *rowreq_ctx, long proEth4tx_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth4tx_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth4tx value.
     * set proEth4tx value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth4tx = proEth4tx_val;

    return MFD_SUCCESS;
} /* proEth4tx_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth4tx_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth4tx_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth4tx undo.
     */
    /*
     * copy proEth4tx data
     * set rowreq_ctx->data.proEth4tx from rowreq_ctx->undo->proEth4tx
     */
    rowreq_ctx->data.proEth4tx = rowreq_ctx->undo->proEth4tx;

    
    return MFD_SUCCESS;
} /* proEth4tx_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proPsctlSts
 * proPsctlSts is subid 58 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.58
 * Description:
CNU port link status control status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proPsctlSts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proPsctlSts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proPsctlSts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proPsctlSts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proPsctlSts value.
     */

    return MFD_SUCCESS; /* proPsctlSts value not illegal */
} /* proPsctlSts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proPsctlSts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proPsctlSts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proPsctlSts undo.
     */
    /*
     * copy proPsctlSts data
     * set rowreq_ctx->undo->proPsctlSts from rowreq_ctx->data.proPsctlSts
     */
    rowreq_ctx->undo->proPsctlSts = rowreq_ctx->data.proPsctlSts;


    return MFD_SUCCESS;
} /* proPsctlSts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proPsctlSts_val
 *        A long containing the new value.
 */
int
proPsctlSts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proPsctlSts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proPsctlSts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proPsctlSts value.
     * set proPsctlSts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proPsctlSts = proPsctlSts_val;

    return MFD_SUCCESS;
} /* proPsctlSts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proPsctlSts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proPsctlSts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proPsctlSts undo.
     */
    /*
     * copy proPsctlSts data
     * set rowreq_ctx->data.proPsctlSts from rowreq_ctx->undo->proPsctlSts
     */
    rowreq_ctx->data.proPsctlSts = rowreq_ctx->undo->proPsctlSts;

    
    return MFD_SUCCESS;
} /* proPsctlSts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth1sts
 * proEth1sts is subid 60 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.60
 * Description:
CNU eth1 port link status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth1sts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth1sts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth1sts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1sts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth1sts value.
     */

    return MFD_SUCCESS; /* proEth1sts value not illegal */
} /* proEth1sts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth1sts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth1sts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth1sts undo.
     */
    /*
     * copy proEth1sts data
     * set rowreq_ctx->undo->proEth1sts from rowreq_ctx->data.proEth1sts
     */
    rowreq_ctx->undo->proEth1sts = rowreq_ctx->data.proEth1sts;


    return MFD_SUCCESS;
} /* proEth1sts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth1sts_val
 *        A long containing the new value.
 */
int
proEth1sts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth1sts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth1sts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth1sts value.
     * set proEth1sts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth1sts = proEth1sts_val;

    return MFD_SUCCESS;
} /* proEth1sts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth1sts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth1sts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth1sts undo.
     */
    /*
     * copy proEth1sts data
     * set rowreq_ctx->data.proEth1sts from rowreq_ctx->undo->proEth1sts
     */
    rowreq_ctx->data.proEth1sts = rowreq_ctx->undo->proEth1sts;

    
    return MFD_SUCCESS;
} /* proEth1sts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth2sts
 * proEth2sts is subid 61 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.61
 * Description:
CNU eth2 port link status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth2sts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth2sts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth2sts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2sts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth2sts value.
     */

    return MFD_SUCCESS; /* proEth2sts value not illegal */
} /* proEth2sts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth2sts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth2sts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth2sts undo.
     */
    /*
     * copy proEth2sts data
     * set rowreq_ctx->undo->proEth2sts from rowreq_ctx->data.proEth2sts
     */
    rowreq_ctx->undo->proEth2sts = rowreq_ctx->data.proEth2sts;


    return MFD_SUCCESS;
} /* proEth2sts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth2sts_val
 *        A long containing the new value.
 */
int
proEth2sts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth2sts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth2sts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth2sts value.
     * set proEth2sts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth2sts = proEth2sts_val;

    return MFD_SUCCESS;
} /* proEth2sts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth2sts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth2sts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth2sts undo.
     */
    /*
     * copy proEth2sts data
     * set rowreq_ctx->data.proEth2sts from rowreq_ctx->undo->proEth2sts
     */
    rowreq_ctx->data.proEth2sts = rowreq_ctx->undo->proEth2sts;

    
    return MFD_SUCCESS;
} /* proEth2sts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth3sts
 * proEth3sts is subid 62 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.62
 * Description:
CNU eth3 port link status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth3sts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth3sts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth3sts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3sts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth3sts value.
     */

    return MFD_SUCCESS; /* proEth3sts value not illegal */
} /* proEth3sts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth3sts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth3sts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth3sts undo.
     */
    /*
     * copy proEth3sts data
     * set rowreq_ctx->undo->proEth3sts from rowreq_ctx->data.proEth3sts
     */
    rowreq_ctx->undo->proEth3sts = rowreq_ctx->data.proEth3sts;


    return MFD_SUCCESS;
} /* proEth3sts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth3sts_val
 *        A long containing the new value.
 */
int
proEth3sts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth3sts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth3sts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth3sts value.
     * set proEth3sts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth3sts = proEth3sts_val;

    return MFD_SUCCESS;
} /* proEth3sts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth3sts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth3sts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth3sts undo.
     */
    /*
     * copy proEth3sts data
     * set rowreq_ctx->data.proEth3sts from rowreq_ctx->undo->proEth3sts
     */
    rowreq_ctx->data.proEth3sts = rowreq_ctx->undo->proEth3sts;

    
    return MFD_SUCCESS;
} /* proEth3sts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proEth4sts
 * proEth4sts is subid 63 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.63
 * Description:
CNU eth4 port link status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proEth4sts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proEth4sts_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth4sts_val)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4sts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proEth4sts value.
     */

    return MFD_SUCCESS; /* proEth4sts value not illegal */
} /* proEth4sts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proEth4sts_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proEth4sts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proEth4sts undo.
     */
    /*
     * copy proEth4sts data
     * set rowreq_ctx->undo->proEth4sts from rowreq_ctx->data.proEth4sts
     */
    rowreq_ctx->undo->proEth4sts = rowreq_ctx->data.proEth4sts;


    return MFD_SUCCESS;
} /* proEth4sts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proEth4sts_val
 *        A long containing the new value.
 */
int
proEth4sts_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proEth4sts_val )
{

    DEBUGMSGTL(("verbose:profileTable:proEth4sts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proEth4sts value.
     * set proEth4sts value in rowreq_ctx->data
     */
    rowreq_ctx->data.proEth4sts = proEth4sts_val;

    return MFD_SUCCESS;
} /* proEth4sts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proEth4sts_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proEth4sts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proEth4sts undo.
     */
    /*
     * copy proEth4sts data
     * set rowreq_ctx->data.proEth4sts from rowreq_ctx->undo->proEth4sts
     */
    rowreq_ctx->data.proEth4sts = rowreq_ctx->undo->proEth4sts;

    
    return MFD_SUCCESS;
} /* proEth4sts_undo */

/*---------------------------------------------------------------------
 * prevail-mib::profileEntry.proCommit
 * proCommit is subid 64 of profileEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.36186.8.8.1.64
 * Description:
Commit action node for saving current profile settings to databases.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param proCommit_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * profileTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
proCommit_check_value( profileTable_rowreq_ctx *rowreq_ctx, u_long proCommit_val)
{
    DEBUGMSGTL(("verbose:profileTable:proCommit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid proCommit value.
     */

    return MFD_SUCCESS; /* proCommit value not illegal */
} /* proCommit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (profileTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * profileTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
proCommit_undo_setup( profileTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:profileTable:proCommit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup proCommit undo.
     */
    /*
     * copy proCommit data
     * set rowreq_ctx->undo->proCommit from rowreq_ctx->data.proCommit
     */
    rowreq_ctx->undo->proCommit = rowreq_ctx->data.proCommit;


    return MFD_SUCCESS;
} /* proCommit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param proCommit_val
 *        A long containing the new value.
 */
int
proCommit_set( profileTable_rowreq_ctx *rowreq_ctx, u_long proCommit_val )
{

    DEBUGMSGTL(("verbose:profileTable:proCommit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set proCommit value.
     * set proCommit value in rowreq_ctx->data
     */
    rowreq_ctx->data.proCommit = proCommit_val;

    return MFD_SUCCESS;
} /* proCommit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
proCommit_undo( profileTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:profileTable:proCommit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up proCommit undo.
     */
    /*
     * copy proCommit data
     * set rowreq_ctx->data.proCommit from rowreq_ctx->undo->proCommit
     */
    rowreq_ctx->data.proCommit = rowreq_ctx->undo->proCommit;

    
    return MFD_SUCCESS;
} /* proCommit_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * profileTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-profileTable if you don't have dependencies)
 */
int
profileTable_check_dependencies(profileTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:profileTable:profileTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check profileTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* profileTable_check_dependencies */

/** @} */
